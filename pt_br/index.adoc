= Princípios Concorrente: Uma Intodução Gentil à Programação Concorrente 
Barry Wittman <wittman1@otterbein.edu>; Tim Korb <jtk@purdue.edu>; Aditya Mathur <apm@purdue.edu>
:doctype: book
:source-highlighter: rouge
:rouge-style: default
:icons: font
:stem: latexmath
:xrefstyle: short
:listing-caption: Program
:google-analytics-account: G-VEDGKRPMMK

ifdef::ebook-format[:leveloffset: -1]

== Disponibilidade

[.text-center]
image::multicore.svg[float="right"]

Esta é uma versão traduzida do texto __Start Concurrent__ publicado originalmente e disponível em 
link:http://www.thepress.purdue.edu/titles/format/9781626710092[Purdue University Press^] ou
link:https://www.amazon.com/Start-Concurrent-Introduction-Problem-Concurrency/dp/1626710090[Amazon^],
além disso o texto também está disponível na íntegra em HTML para leitura em um navegador web.
A versão HTML está disponível como um documento único (o que permite uma pesquisa fácil) e dividida 
num documento separado para cada capítulo (o que reduz o tempo de carregamento). Clique em um __link__ 
abaixo para acessar à versão pretendida.

* link:full/index.html[HTML (documento único)]
* link:chunked/index.html[HTML (dividido)]

== Está utilizando __Start Concurrent__?

Se já utiliza o __Start Concurrent__ na sua sala de aula, conte pra gente!  Por favor, envie um e-mail para wittman1@otterbein.edu
e diga-nos em que disciplina utiliza o livro.  Se algumas alterações ao livro tornarem a sua aula mais fácil de lecionar, gostaríamos de
saber quais são.

== Nos ajude!

.Atualizações recentes!
[]
====
Fizemos algumas atualizações (Junho 2023) recentes, principalmente para atender aos requisitos do Google Analytics.  Se você notar algum erro ou formatação incomum, nos informe!
====

Nós apreciamos seus comentários e sugestões!
Por favor envie como uma 
link:https://github.com/start-concurrent/start-concurrent.github.io/issues[Github issue^]
ou (para os corajosos) copie o 
link:https://github.com/start-concurrent/start-concurrent.github.io[repositório Github^],
faça alterações no código fonte e submeta um __pull request__.

== Sobre

Bem-vindo ao __Start Concurrent__!
Este livro foi concebido como um ponto de entrada para o desafiador domínio da 
computação multicore. Ele foi projetado para apresentar aos alunos a programação 
concorrente ao mesmo tempo em que eles aprendem os fundamentos da programação 
sequencial, no início da faculdade. Depois de dominar os conceitos abordados 
aqui, os alunos devem estar preparados quando se depararem com formas mais 
complexas de concorrência em cursos avançados e no local de trabalho. Uma 
geração de alunos que aprende a concorrência em seu primeiro curso estará pronta 
para explorar todo o poder dos chips com vários núcleos quando ingressar no mercado 
de trabalho.

Os processadores multicore são onipresentes. Quer você use um desktop, um laptop ou 
até mesmo um smartphone, é bem provável que seu computador tenha um chip multicore 
em seu coração. Computadores paralelos de baixo custo foram profetizados durante anos. 
Esse momento chegou. Os computadores paralelos estão em nossas mãos e em nossos bolsos. 
Esse progresso na tecnologia de microprocessadores lançou um desafio aos educadores: __Como 
podemos ensinar programação simultânea?__

A programação de computadores tem sido ensinada no meio acadêmico há décadas. No 
entanto, o objetivo não escrito em quase todas as aulas de programação para iniciantes 
tem sido ensinar os alunos a escrever, compilar, testar e depurar programas *sequenciais*. 
O material relacionado à programação simultânea geralmente é deixado para cursos sobre 
sistemas operacionais e linguagens de programação ou cursos de computação de alto 
desempenho. Agora que os computadores paralelos estão em toda parte, devemos considerar 
introduzir os fundamentos da programação simultânea em aulas para iniciantes em programação?


De nossa parte, acreditamos que a programação simultânea pode e deve ser ensinada aos alunos 
do primeiro ano. Este livro tem como objetivo apresentar a programação concorrente praticamente 
desde o primeiro dia. A justificativa para nossa crença deriva de outra crença de que o pensamento 
processual, tanto sequencial quanto concorrente, é natural. As pessoas sabiam como resolver 
problemas de maneira sequencial, muito antes de o estudo de algoritmos se tornar um disciplina 
formal e a ciência da computação um curso formal. E essa lógica se aplica à solução de problemas 
usando um conjunto de soluções sequenciais aplicadas simultaneamente. Observe um cozinheiro na 
cozinha e você verá a simultaneidade em ação. Assista a um filme e você verá a simultaneidade em 
ação à medida que várias subtramas, cenas e flashbacks história. Os pais usam soluções simultâneas 
para resolver problemas cotidianos enquanto lidam com os cuidados com os filhos, a carreira e a 
vida social.


Se as pessoas resolvem naturalmente os problemas de forma sequencial e simultânea, por que 
precisamos ensinar programação? A programação é uma maneira de mapear uma solução algorítmica 
de um problema em uma linguagem artificial, como Java. É uma atividade que requer análise 
formal, vocabulário especializado e lógica afiada. A verdadeira substância intelectual da 
programação está nesse processo de mapeamento. Qual é a melhor maneira de transformar uma 
solução sequencial em uma linguagem artificial? Como uma solução sequencial pode ser dividida 
em partes simultâneas que são executadas mais rapidamente do que a original? Como um problema 
grande problema pode ser dividido em partes pequenas e gerenciáveis que podem ser programadas 
separadamente e depois integrados em um todo? Além disso, há questões de testes, depuração, 
documentação e gerenciamento do processo de desenvolvimento de software, que se combinam para 
tornar a programação um campo ilimitado para o esforço intelectual.

=== Target audience

This book is intended to teach college level students with no programming
experience over a period of two semesters. Although we start with concurrency
concepts from the very beginning, it's difficult for students with no
prior programming experience to write useful multithreaded programs by the end
of their first semester.  By the end of the second semester, however, this book
can lead a student from a blank slate to a capable programmer of complex
parallel programs that exploit the power of multicore processors.


The content in this book could also be used for single semester courses.
Chapters 1 through 12 are intended for the absolute beginner. If you don't want
to introduce concurrent programming in a first course, these chapters should
prove adequate. The concurrency material and exercises in these chapters can be ignored without negatively impacting the other
material. For a second course in programming, Chapters 1 through 12 should be
used as review material as well as an introduction to concurrent programming.
Most material from Chapters 13 onward could then be covered in a single semester.


=== Material covered

Java is a complex language. Its long list of features makes it difficult for
an instructor to decide what to cover and what to leave out. Often there's a
tendency to cover more material than less. We've noticed that today's student
uses not only a textbook but also the large volume of material available on the
web to learn any subject, including programming. Our focus is consequently
more on fundamental elements of programming and less on giving a complete
description of Java, which is itself still a living and evolving language. Where appropriate we direct the student to websites where
relevant reference material can be found.

Classes and objects are an essential part of Java.  Some educators have
adopted an "`objects early`" approach that focuses heavily on object oriented
principles from the very beginning.  Although we see many merits in this
approach, we feel compelled to start with logic, arithmetic, and control flow so
that students have a firm foundation of what to put inside their objects. A full
treatment of classes and objects unfolds throughout the book, moving
naturally from monolithic programs to decomposition into methods to full
object orientation.

=== Organization

The material covered can be divided up in different ways depending on the needs
of the instructor or the student. Chapters 1 through 12, with the exception of
Chapter 7, are designed to introduce the student to Java and programming in
general. Chapters 7 and 15 cover material related to graphical user interfaces
and can be skipped if these topics are not of interest. Chapters 13 and 14 give
an in-depth treatment of the concurrency features of Java.  Although we make an
effort to mark concurrency material and keep it independent from the rest of the
content, those chapters numbered 15 and higher will assume some knowledge and
interest in concurrency. Chapter 15 itself covers debugging and testing, which
is even more crucial in a concurrent environment. The rest of the book covers
advanced material relating to OO design, data structures, and I/O.

=== Chapter layout

One feature of this book that separates it from many Java textbooks is its
problem-driven approach.  Most chapters are divided into the following parts.

Problem:: A motivating problem is given at the beginning
of almost all chapters.  This problem is intended to show the value of the
material covered in the chapter as well as sketching a practical application.
Concepts:: One or more short sections devoted to concepts
is given in each chapter.  The concepts described in these sections are the
fundamental topics covered in the chapter, as well as main ideas needed to solve the chapter's motivating problem. These concepts are intended to be broad and language neutral.  Java syntax is kept to an absolute minimum in these sections.
Syntax:: Each chapter has one or more sections describing
the Java syntax needed to implement the concepts already described in the
Concepts sections.  These sections are typically longer and have numbered
examples in Java code sprinkled throughout.
Solution:: After the appropriate concepts and Java syntax
needed to solve the motivating problem have been given, a solution to the
motivating problem is provided near the end of the chapter.  In this way,
students are given plenty of time to think about the approach needed to solve
the problem before the answer is given.
Concurrency:: For all of the chapters except for
Chapters 13 and 14, the dedicated concurrency chapters, additional relevant
concurrency concepts and syntax are introduced in these specially marked
sections, spreading concurrency throughout the book.
Exercises:: Each chapter ends with exercises, which are
divided into three sections: Conceptual Problems, Programming Practice, and
Experiments. Most Conceptual Problems are simple and are intended as a quick
test of the student's understanding. Problems in Programming Practice require
students to implement a short program in Java and can be used as homework
assignments.  Experiments are a special feature of this textbook and are
especially appropriate in the context of concurrency.  Experiments focus on the performance of a program, usually in terms of speed or memory usage.   Students will need to run short programs and measure their running time or other features, gaining practical insight into speedup and other advantages and challenges of concurrency. References to exercises are given throughout the chapter text.

We hope that structuring chapters in this way can be useful for many different
kinds of readers. Novice programmers may wish to read each chapter from start to
end.  Experienced programmers who have never programmed Java may focus primarily
on the *Syntax* sections to learn the appropriate Java syntax and
semantics. Rusty Java programmers may prefer to focus on the clearly
numbered examples and exercises. Of course, instructors are encouraged to use
the motivating problems to motivate their lectures as well.

In addition, specially marked *Pitfall* sections throughout the book
highlight common programming errors and mistakes.


=== What topics does this book not cover?

This book is not intended to be a comprehensive guide to Java. Instead, it's
intended to teach how to use computers to solve problems, especially
concurrently. Java has a marvelous wealth of packages and libraries that we
don't have the space to cover. For example, the Swing package for
building user interfaces is discussed but not in its entirety. For material not found in this book, we expect students to refer to the material available on the link:http://download.oracle.com/javase/tutorial[Oracle Java tutorial website] and other reference
books and websites.

=== Suggestions

Java IDE:: It's important that the students be introduced to a Java IDE
very early in the course. We recommend that students use a simpler rather than a more complex IDE. We have successfully used DrJava though other simple IDEs
might work just as well. For instructors hoping to give their students
experience with an industry-level IDE, we give examples using Eclipse as well as
DrJava in the chapter on testing and debugging and a few other times when
relevant.
Concurrency at the start:: Many courses begin with a
lecture or two on the relationship between problem-solving and computers.
Chapter 2 covers this topic. During these very early lectures, instructors
can introduce the notions of both sequential and concurrent solutions. One
could use simple problems from areas such as mathematics or physics or even day-to-day life that lead to sequential and concurrent solutions. Early exposure to solutions these problems, programmed in Java, can be beneficial students even if they don't understand all the syntax.
Input and output:: The issue of what input
and output material to cover can be dealt with in several ways. While
programming attractive GUIs may be exciting, some instructors prefer to
postpone detailed treatment of GUI-related material until late in a course. In
this book we've decided to follow a flexible approach. We begin by discussing the use of `System.out.print()` and `Scanner` and the
`JOptionPane` class as alternatives for basic input and output.  Our
assumption is that most instructors will prefer the simplicity of command line
I/O; however, those who favor a more GUI-heavy approach can start early in
Chapter 7 for GUI basics and
eventually move onto Chapter 15 for more depth in GUIs and Swing. Instructors who wish to concentrate only on command line I/O are free to ignore these chapters.

== Acknowledgements

A number of people have played a significant role in motivating the authors to undertake the task of writing this book and in the choice of topics. First, during the spring of 2008, several faculty from the Department of Computer Science and a scientist from Purdue's ITaP, participated in early discussions related to the teaching of concurrent programming in freshman classes. Despite the multitude of issues raised, all participants seemed to agree on one point: that we ought to introduce concurrency early in the Computer Science undergraduate curriculum. Thanks to all the participants, namely, Buster Dunsmore, Ananth Grama, Suresh Jagannathan, Sunil Prabhakar, Faisal Saied, and Jan Vitek.  We benefited from advice, encouragement, and support from a number of alumni and corporate partners; special thanks to Kevin Kahn, Andrew Chien, and Carl Murray.

Thanks to the many anonymous reviewers who carefully read through Draft 3.0 of this manuscript and made valuable suggestions. This current draft would not exist without the many suggestions and critiques of these reviewers.

In the fall of 2008, we offered an experimental freshman class entitled "`Introduction to Programming with Concurrency.`" This class was certainly one of the best we have taught to freshmen.  Thanks to Alexander Bartol, Alexander Coe, Eric Fisher, Benjamin Gilliland-Sauer, John Graff, Tyler Holzer, Kelly, Jordan Kelly, Azfar Khandoker, Zackary Naas, Ravi Pareek, Carl Rhodes, Robert Schwalm, Andrew Wirtz, and Christopher Womble.

Special thanks to Azfar Khandoker who not only attended this initial class, but also worked on an independent study project to create exercises using Lego robots to help students learn programming. Azfar's work has led to the use of robots in two freshman programming classes taught at Purdue.

We appreciate the support and cooperation of the faculty, and their students, who are our first test users: Professor David John of Wake Forest University and Professor Sunil Prabhakar of Purdue University.

Finally, we thank everyone in the open source community who has submitted issues, questions, or pull requests through link:https://github.com/[Github^].
