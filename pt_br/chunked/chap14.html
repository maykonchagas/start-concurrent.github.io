<!DOCTYPE html><html lang="pt_BR"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<meta name="author" content="Barry Wittman, Tim Korb, Aditya Mathur">
<title>Começando Concorrente: Uma Introdução Gentil à Programação Concorrente</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="style0.css" type="text/css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="style1.css" type="text/css">
<link rel="stylesheet" href="asciidoctor-chunker.css" type="text/css"></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Começando Concorrente: Uma Introdução Gentil à Programação Concorrente</h1>
<div class="details">
<span id="author" class="author">Barry Wittman</span><br>
<span id="email" class="email"><a href="mailto:wittman1@otterbein.edu">wittman1@otterbein.edu</a></span><br>
<span id="author2" class="author">Tim Korb</span><br>
<span id="email2" class="email"><a href="mailto:jtk@purdue.edu">jtk@purdue.edu</a></span><br>
<span id="author3" class="author">Aditya Mathur</span><br>
<span id="email3" class="email"><a href="mailto:apm@purdue.edu">apm@purdue.edu</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<ul class="sectlevel1">
<li><a href="index.html">Começando Concorrente</a></li><li><a href="index.html">Capítulo 1. Computer Basics</a>
<ul class="sectlevel2">
<li><a href="index.html#_problem_buying_a_computer">1.1. Problem: Buying a computer</a></li>
<li><a href="index.html#_concepts_hardware_and_software">1.2. Concepts: Hardware and software</a></li>
<li><a href="index.html#_syntax_data_representation">1.3. Syntax: Data representation</a></li>
<li><a href="index.html#_solution_buying_a_computer">1.4. Solution: Buying a computer</a></li>
<li><a href="index.html#_summary">1.5. Summary</a></li>
<li><a href="index.html#_exercises">1.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap2.html">Capítulo 2. Problem Solving and Programming</a>
<ul class="sectlevel2">
<li><a href="chap2.html#_problem_how_to_solve_problems">2.1. Problem: How to solve problems</a></li>
<li><a href="chap2.html#_concepts_developing_software">2.2. Concepts: Developing software</a></li>
<li><a href="chap2.html#_syntax_java_basics">2.3. Syntax: Java basics</a></li>
<li><a href="chap2.html#_solution_how_to_solve_problems">2.4. Solution: How to solve problems</a></li>
<li><a href="chap2.html#_concurrency_solving_problems_in_parallel">2.5. Concurrency: Solving problems in parallel</a></li>
<li><a href="chap2.html#_summary_2">2.6. Summary</a></li>
<li><a href="chap2.html#_exercises_2">2.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap3.html">Capítulo 3. Primitive Types and Strings</a>
<ul class="sectlevel2">
<li><a href="chap3.html#_problem_college_cost_calculator">3.1. Problem: College cost calculator</a></li>
<li><a href="chap3.html#_concepts_types">3.2. Concepts: Types</a></li>
<li><a href="chap3.html#_syntax_types_in_java">3.3. Syntax: Types in Java</a></li>
<li><a href="chap3.html#_syntax_useful_libraries">3.4. Syntax: Useful libraries</a></li>
<li><a href="chap3.html#_solution_college_cost_calculator">3.5. Solution: College cost calculator</a></li>
<li><a href="chap3.html#_concurrency_expressions">3.6. Concurrency: Expressions</a></li>
<li><a href="chap3.html#_summary_3">3.7. Summary</a></li>
<li><a href="chap3.html#_exercises_3">3.8. Exercises</a></li>
</ul>
</li>
<li><a href="chap4.html">Capítulo 4. Selection</a>
<ul class="sectlevel2">
<li><a href="chap4.html#_problem_monty_hall_simulation">4.1. Problem: Monty Hall simulation</a></li>
<li><a href="chap4.html#_concepts_choosing_between_options">4.2. Concepts: Choosing between options</a></li>
<li><a href="chap4.html#_syntax_selection_in_java">4.3. Syntax: Selection in Java</a></li>
<li><a href="chap4.html#_solution_monty_hall">4.4. Solution: Monty Hall</a></li>
<li><a href="chap4.html#_concurrency_selection">4.5. Concurrency: Selection</a></li>
<li><a href="chap4.html#_exercises_4">4.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap5.html">Capítulo 5. Repetition</a>
<ul class="sectlevel2">
<li><a href="chap5.html#_problem_dna_searching">5.1. Problem: DNA searching</a></li>
<li><a href="chap5.html#_concepts_repetition">5.2. Concepts: Repetition</a></li>
<li><a href="chap5.html#_syntax_loops_in_java">5.3. Syntax: Loops in Java</a></li>
<li><a href="chap5.html#_solution_dna_searching">5.4. Solution: DNA searching</a></li>
<li><a href="chap5.html#_concurrency_loops">5.5. Concurrency: Loops</a></li>
<li><a href="chap5.html#_exercises_5">5.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap6.html">Capítulo 6. Arrays</a>
<ul class="sectlevel2">
<li><a href="chap6.html#_introduction">6.1. Introduction</a></li>
<li><a href="chap6.html#_problem_game_of_life">6.2. Problem: Game of Life</a></li>
<li><a href="chap6.html#_concepts_lists_of_data">6.3. Concepts: Lists of data</a></li>
<li><a href="chap6.html#_syntax_arrays_in_java">6.4. Syntax: Arrays in Java</a></li>
<li><a href="chap6.html#_examples_array_usage">6.5. Examples: Array usage</a></li>
<li><a href="chap6.html#_concepts_multidimensional_lists">6.6. Concepts: Multidimensional lists</a></li>
<li><a href="chap6.html#_syntax_advanced_arrays_in_java">6.7. Syntax: Advanced arrays in Java</a></li>
<li><a href="chap6.html#_examples_two_dimensional_arrays">6.8. Examples: Two-dimensional arrays</a></li>
<li><a href="chap6.html#_advanced_special_array_tools_in_java">6.9. Advanced: Special array tools in Java</a></li>
<li><a href="chap6.html#_solution_game_of_life">6.10. Solution: Game of Life</a></li>
<li><a href="chap6.html#_concurrency_arrays">6.11. Concurrency: Arrays</a></li>
<li><a href="chap6.html#_exercises_6">6.12. Exercises</a></li>
</ul>
</li>
<li><a href="chap7.html">Capítulo 7. Simple Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap7.html#_problem_codon_extractor">7.1. Problem: Codon extractor</a></li>
<li><a href="chap7.html#GUIBasicsIntroductionSection">7.2. Concepts: User interaction</a></li>
<li><a href="chap7.html#_syntax_dialogs_and_the_joptionpane_class">7.3. Syntax: Dialogs and the <code>JOptionPane</code> class</a></li>
<li><a href="chap7.html#_solution_codon_extractor">7.4. Solution: Codon extractor</a></li>
<li><a href="chap7.html#_concurrency_simple_guis">7.5. Concurrency: Simple GUIs</a></li>
<li><a href="chap7.html#_summary_4">7.6. Summary</a></li>
<li><a href="chap7.html#_exercises_7">7.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap8.html">Capítulo 8. Methods</a>
<ul class="sectlevel2">
<li><a href="chap8.html#_problem_three_card_poker">8.1. Problem: Three card poker</a></li>
<li><a href="chap8.html#_concepts_dividing_work_into_segments">8.2. Concepts: Dividing work into segments</a></li>
<li><a href="chap8.html#_syntax_methods">8.3. Syntax: Methods</a></li>
<li><a href="chap8.html#_examples_defining_methods">8.4. Examples: Defining methods</a></li>
<li><a href="chap8.html#_solution_three_card_poker">8.5. Solution: Three card poker</a></li>
<li><a href="chap8.html#_concurrency_methods">8.6. Concurrency: Methods</a></li>
<li><a href="chap8.html#_exercises_8">8.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap9.html">Capítulo 9. Classes</a>
<ul class="sectlevel2">
<li><a href="chap9.html#_problem_nested_expressions">9.1. Problem: Nested expressions</a></li>
<li><a href="chap9.html#_concepts_object_oriented_programming">9.2. Concepts: Object-oriented programming</a></li>
<li><a href="chap9.html#_syntax_classes_in_java">9.3. Syntax: Classes in Java</a></li>
<li><a href="chap9.html#_advanced_nested_classes">9.4. Advanced: Nested classes</a></li>
<li><a href="chap9.html#_solution_nested_expressions">9.5. Solution: Nested expressions</a></li>
<li><a href="chap9.html#_concurrency_objects">9.6. Concurrency: Objects</a></li>
<li><a href="chap9.html#_exercises_9">9.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap10.html">Capítulo 10. Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap10.html#_problem_sort_it_out">10.1. Problem: Sort it out</a></li>
<li><a href="chap10.html#_concepts_making_a_promise">10.2. Concepts: Making a promise</a></li>
<li><a href="chap10.html#_syntax_interfaces">10.3. Syntax: Interfaces</a></li>
<li><a href="chap10.html#_advanced_local_and_anonymous_classes">10.4. Advanced: Local and anonymous classes</a></li>
<li><a href="chap10.html#_solution_sort_it_out">10.5. Solution: Sort it out</a></li>
<li><a href="chap10.html#_concurrency_interfaces">10.6. Concurrency: Interfaces</a></li>
<li><a href="chap10.html#_exercises_10">10.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap11.html">Capítulo 11. Inheritance</a>
<ul class="sectlevel2">
<li><a href="chap11.html#_problem_boolean_circuits">11.1. Problem: Boolean circuits</a></li>
<li><a href="chap11.html#_concepts_refining_classes">11.2. Concepts: Refining classes</a></li>
<li><a href="chap11.html#_syntax_inheritance_in_java">11.3. Syntax: Inheritance in Java</a></li>
<li><a href="chap11.html#_examples_problem_solving_with_inheritance">11.4. Examples: Problem solving with inheritance</a></li>
<li><a href="chap11.html#_solution_boolean_circuits">11.5. Solution: Boolean circuits</a></li>
<li><a href="chap11.html#_concurrency_inheritance">11.6. Concurrency: Inheritance</a></li>
<li><a href="chap11.html#_exercises_11">11.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap12.html">Capítulo 12. Exceptions</a>
<ul class="sectlevel2">
<li><a href="chap12.html#_problem_bank_burglary">12.1. Problem: Bank burglary</a></li>
<li><a href="chap12.html#_concepts_error_handling">12.2. Concepts: Error handling</a></li>
<li><a href="chap12.html#_syntax_exceptions_in_java">12.3. Syntax: Exceptions in Java</a></li>
<li><a href="chap12.html#_solution_bank_burglary">12.4. Solution: Bank burglary</a></li>
<li><a href="chap12.html#_concurrency_exceptions">12.5. Concurrency: Exceptions</a></li>
<li><a href="chap12.html#_exercises_12">12.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap13.html">Capítulo 13. Programação Concorrente</a>
<ul class="sectlevel2">
<li><a href="chap13.html#_introdução">13.1. Introdução</a></li>
<li><a href="chap13.html#_problema_vírus_mortal">13.2. Problema: Vírus mortal</a></li>
<li><a href="chap13.html#_conceitos_dividindo_para_conquistar">13.3. Conceitos: Dividindo para conquistar</a></li>
<li><a href="chap13.html#_sintaxe_threads_em_java">13.4. Sintaxe: Threads em Java</a></li>
<li><a href="chap13.html#_exemplos_concorrência_e_aceleração">13.5. Exemplos: Concorrência e aceleração</a></li>
<li><a href="chap13.html#_conteitos_agendamento_de_thread">13.6. Conteitos: Agendamento de thread</a></li>
<li><a href="chap13.html#_sintaxe_estados_da_thread">13.7. Sintaxe: Estados da thread</a></li>
<li><a href="chap13.html#_solução_vírus_mortal">13.8. Solução: Vírus mortal</a></li>
<li><a href="chap13.html#_resumo">13.9. Resumo</a></li>
<li><a href="chap13.html#_exercícios">13.10. Exercícios</a></li>
</ul>
</li>
<li class="current"><a href="chap14.html">Capítulo 14. Sincronização</a>
<ul class="sectlevel2">
<li class="current"><a href="chap14.html#_introdução_2">14.1. Introdução</a></li>
<li class="current"><a href="chap14.html#_problema_jantar_dos_filósofos">14.2. Problema: Jantar dos filósofos</a></li>
<li class="current"><a href="chap14.html#_conceitos_interação_de_thread">14.3. Conceitos: Interação de thread</a></li>
<li class="current"><a href="chap14.html#_sintaxe_sincronização_de_thread">14.4. Sintaxe: Sincronização de thread</a></li>
<li class="current"><a href="chap14.html#_pitfalls_synchronization_challenges">14.5. Pitfalls: Synchronization challenges</a></li>
<li class="current"><a href="chap14.html#_solution_dining_philosophers">14.6. Solution: Dining philosophers</a></li>
<li class="current"><a href="chap14.html#_exercises_13">14.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap15.html">Capítulo 15. Constructing Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap15.html#_problem_math_tutor">15.1. Problem: Math tutor</a></li>
<li><a href="chap15.html#_concepts_graphical_user_interfaces">15.2. Concepts: Graphical user interfaces</a></li>
<li><a href="chap15.html#_syntax_guis_in_java">15.3. Syntax: GUIs in Java</a></li>
<li><a href="chap15.html#_solution_math_tutor">15.4. Solution: Math tutor</a></li>
<li><a href="chap15.html#_concurrency_guis">15.5. Concurrency: GUIs</a></li>
<li><a href="chap15.html#_summary_5">15.6. Summary</a></li>
<li><a href="chap15.html#_exercises_14">15.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap16.html">Capítulo 16. Testing and Debugging</a>
<ul class="sectlevel2">
<li><a href="chap16.html#_fixing_bugs">16.1. Fixing bugs</a></li>
<li><a href="chap16.html#_concepts_approaches_to_debugging">16.2. Concepts: Approaches to debugging</a></li>
<li><a href="chap16.html#_syntax_java_debugging_tools">16.3. Syntax: Java debugging tools</a></li>
<li><a href="chap16.html#_concurrency_parallel_bugs">16.4. Concurrency: Parallel bugs</a></li>
<li><a href="chap16.html#_finding_and_avoiding_bugs">16.5. Finding and avoiding bugs</a></li>
<li><a href="chap16.html#_concepts_design_implementation_and_testing">16.6. Concepts: Design, implementation, and testing</a></li>
<li><a href="chap16.html#_syntax_java_testing_tools">16.7. Syntax: Java testing tools</a></li>
<li><a href="chap16.html#_concurrency_testing_tools">16.8. Concurrency: Testing tools</a></li>
<li><a href="chap16.html#_examples_testing_a_class">16.9. Examples: Testing a class</a></li>
<li><a href="chap16.html#_exercises_15">16.10. Exercises</a></li>
</ul>
</li>
<li><a href="chap17.html">Capítulo 17. Polymorphism</a>
<ul class="sectlevel2">
<li><a href="chap17.html#_problem_banking_account_with_a_vengeance">17.1. Problem: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concepts_polymorphism">17.2. Concepts: Polymorphism</a></li>
<li><a href="chap17.html#_syntax_inheritance_tools_in_java">17.3. Syntax: Inheritance tools in Java</a></li>
<li><a href="chap17.html#_solution_banking_account_with_a_vengeance">17.4. Solution: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concurrency_atomic_libraries">17.5. Concurrency: Atomic libraries</a></li>
<li><a href="chap17.html#_exercises_16">17.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap18.html">Capítulo 18. Dynamic Data Structures</a>
<ul class="sectlevel2">
<li><a href="chap18.html#_problem_infix_conversion">18.1. Problem: Infix conversion</a></li>
<li><a href="chap18.html#_concepts_dynamic_data_structures">18.2. Concepts: Dynamic data structures</a></li>
<li><a href="chap18.html#_syntax_dynamic_arrays_and_linked_lists">18.3. Syntax: Dynamic arrays and linked lists</a></li>
<li><a href="chap18.html#_syntax_abstract_data_types_adt">18.4. Syntax: Abstract data types (ADT)</a></li>
<li><a href="chap18.html#_advanced_generic_data_structures">18.5. Advanced: Generic data structures</a></li>
<li><a href="chap18.html#_solution_infix_conversion">18.6. Solution: Infix conversion</a></li>
<li><a href="chap18.html#_concurrency_linked_lists_and_thread_safety">18.7. Concurrency: Linked lists and thread safety</a></li>
<li><a href="chap18.html#_concurrency_thread_safe_libraries">18.8. Concurrency: Thread-safe libraries</a></li>
<li><a href="chap18.html#_exercises_17">18.9. Exercises</a></li>
</ul>
</li>
<li><a href="chap19.html">Capítulo 19. Recursion</a>
<ul class="sectlevel2">
<li><a href="chap19.html#_problem_maze_of_doom">19.1. Problem: Maze of doom</a></li>
<li><a href="chap19.html#_concepts_recursive_problem_solving">19.2. Concepts: Recursive problem solving</a></li>
<li><a href="chap19.html#_syntax_recursive_methods">19.3. Syntax: Recursive methods</a></li>
<li><a href="chap19.html#_syntax_recursive_data_structures">19.4. Syntax: Recursive data structures</a></li>
<li><a href="chap19.html#_solution_maze_of_doom">19.5. Solution: Maze of doom</a></li>
<li><a href="chap19.html#_concurrency_futures">19.6. Concurrency: Futures</a></li>
<li><a href="chap19.html#_exercises_18">19.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap20.html">Capítulo 20. File I/O</a>
<ul class="sectlevel2">
<li><a href="chap20.html#_problem_a_picture_is_worth_1000_bytes">20.1. Problem: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concepts_file_io">20.2. Concepts: File I/O</a></li>
<li><a href="chap20.html#_syntax_file_operations_in_java">20.3. Syntax: File operations in Java</a></li>
<li><a href="chap20.html#_examples_file_examples">20.4. Examples: File examples</a></li>
<li><a href="chap20.html#fileChapterSolution">20.5. Solution: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concurrency_file_io">20.6. Concurrency: File I/O</a></li>
<li><a href="chap20.html#_exercises_19">20.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap21.html">Capítulo 21. Network Communication</a>
<ul class="sectlevel2">
<li><a href="chap21.html#_problem_web_server">21.1. Problem: Web server</a></li>
<li><a href="chap21.html#_concepts_tcpip_communication">21.2. Concepts: TCP/IP communication</a></li>
<li><a href="chap21.html#_syntax_networking_in_java">21.3. Syntax: Networking in Java</a></li>
<li><a href="chap21.html#_solution_web_server">21.4. Solution: Web server</a></li>
<li><a href="chap21.html#_concurrency_networking">21.5. Concurrency: Networking</a></li>
<li><a href="chap21.html#_exercises_20">21.6. Exercises</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">





















<div class="sect1">
<h2 id="ch14-synchronization">Capítulo 14. Sincronização</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Compartilhar é algumas vezes mais custoso do que dar.</p>
</div>
</blockquote>
<div class="attribution">
— Mary Catherine Bateson
</div>
</div>
<div class="sect2">
<h3 id="_introdução_2">14.1. Introdução</h3>
<div class="paragraph">
<p>Os programas concorrentes permitem que várias threads sejam programadas e executadas,
mas o programador não tem muito controle sobre quando as threads são executadas. Conforme explicado em <a href="#Conceitos: Agendamento de threads" class="target-missing">[Conceitos: Agendamento de threads]</a>,
a JVM e o sistema operacional subjacente são responsáveis pelo agendamento de threads
nos núcleos do processador.</p>
</div>
<div class="paragraph">
<p>Ao escrever um programa concorrente, você precisa garantir que o programa
funcione corretamente, mesmo que diferentes execuções do mesmo programa
provavelmente levarão a diferentes sequências de execução de threads. O problema
que apresentaremos a seguir ilustra por que uma sequência de execução de thread pode ser
perfeitamente bem, enquanto outra pode levar a um comportamento inesperado e incorreto. (E até mesmo pessoas morrendo de fome!)</p>
</div>
</div>
<div class="sect2">
<h3 id="_problema_jantar_dos_filósofos">14.2. Problema: Jantar dos filósofos</h3>
<div class="paragraph">
<p>A concorrente nos dá o potencial de tornar nossos programas mais rápidos, mas
introduz uma série de outros problemas. A maneira como as threads interagem pode
ser imprevisível. Como elas compartilham memória, uma thread pode corromper um valor
nas variáveis de outra thread. Apresentamos as ferramentas de sincronização
neste capítulo que podem evitar que os threads corrompam os dados, mas essas
ferramentas criam novas armadilhas. Para explorar essas armadilhas, apresentamos a você
outro problema para resolver.</p>
</div>
<div class="paragraph">
<p>Imagine vários filósofos sentados em uma mesa redonda com pratos
que são periodicamente preenchidos com arroz. Entre os filósofos adjacentes
estão pauzinhos individuais, de modo que há exatamente o mesmo número de
pauzinhos que o número de filósofos. Esses filósofos só pensam e
comem. Para comer, um filósofo deve pegar o pauzinho à
esquerdo e o da direita. <a href="chap14.html#figure-dining">Figura 14.1</a> ilustra essa
situação.</p>
</div>
<div id="figure-dining" class="imageblock text-center">
<div class="content">
<img src="chapters/14-synchronization/images/diners.svg" alt="diners" width="50%">
</div>
<div class="title">Figura 14.1 Mesa para cinco filósofos em um jantar.</div>
</div>
<div class="paragraph">
<p>Seu objetivo é escrever uma classe chamada <code>DiningPhilosopher</code> que estende
<code>Thread</code>. Cada thread criada no método <code>main()</code> deve ser um
filósofo que pensa por algum tempo aleatório, depois pega os dois pauzinhos necessários e come. Nenhum filósofo deve passar fome. Nenhum dos
filósofos deveria ficar preso indefinidamente brigando por pauzinhos.</p>
</div>
<div class="paragraph">
<p>Embora esse problema pareça simples, a solução não é.
Certifique-se de que você entendeu bem os conceitos e a sintaxe Java deste
capítulo completamente antes de tentar implementar sua solução. É importante que não haja dois filósofos tentando usar o mesmo pauzinho ao
mesmo tempo. Da mesma forma, precisamos evitar uma situação em que cada
filósofo esteja esperando que todos os outros filósofos desistam de um
pauzinho.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conceitos_interação_de_thread">14.3. Conceitos: Interação de thread</h3>
<div class="paragraph">
<p>Esse problema do jantar dos filósofos destaca algumas dificuldades
que estavam surgindo no final do último capítulo. Em
<a href="chap13.html#sharedThreadVariableExercise">Exercício 13.10</a> dois trechos de código poderiam ser executados
concorrentemente e modificar a mesma variável compartilhada, potencialmente produzindo uma
saída incorreta. Devido à natureza não determinística do agendamento,
temos de presumir que o código executado em duas ou mais threads pode ser
intercalados de qualquer maneira possível. Quando o <strong>resultado</strong> da computação
muda dependendo da ordem de execução da thread, ele é chamado de
<em>condição de corrida</em> (ou _race condition, em inglês). Abaixo está um
exemplo simples de uma condição de corrida em Java.</p>
</div>
<div id="RaceConditionProgram" class="listingblock">
<div class="title">Programa 14.1 Exemplo simples de uma condição de corrida</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RaceCondition</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>     
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREADS</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">COUNT</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">;</span>        
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>                              
        <span class="nc">RaceCondition</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RaceCondition</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span>           
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RaceCondition</span><span class="o">();</span>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>         
        <span class="o">}</span>           
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>           
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Counter:\t"</span> <span class="o">+</span> <span class="n">counter</span><span class="o">);</span>            
    <span class="o">}</span>   
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">COUNT</span><span class="o">/</span><span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">counter</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa classe curta (e sem sentido) tenta incrementar a variável <code>counter</code>
até que ela atinja <code>1000000</code>. Para ilustrar a condição de corrida,
dividimos o trabalho de incrementar <code>counter</code> igualmente entre vários
threads. Se você executar esse programa, o valor final de <code>counter
geralmente não será `1000000</code>. Dependendo de qual JVM, sistema operacional e quantos núcleos
você tem, talvez nunca obtenha <code>1000000</code>, e a resposta que você obtiver
variar muito. Em todos os sistemas, se você alterar o valor de <code>THREADS</code>
para <code>1</code>, a resposta deverá estar sempre correta.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#raceConditionExercise">[raceConditionExercise]</a><br>
<a href="chap14.html#threadTimeSliceExercise">[threadTimeSliceExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Observando o código, o problema pode não ser óbvio. Tudo
está centrado na instrução <code>counter++</code> no loop <code>for</code> dentro
método <code>run()</code>. Porém, essa instrução parece ser executada em uma única etapa!
Cada thread deve aumentar o valor de <code>counter</code> em um total de
<code>COUNT/THREADS</code> vezes, somando até <code>1000000</code>. O problema é que
<code>counter++</code> <strong>não</strong> é uma única etapa. Lembre-se de que <code>counter++</code> é uma abreviação
para <code>contador = contador + 1</code>. Para ser ainda mais explícito, poderíamos escrever
da seguinte forma.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">temp</span> <span class="o">=</span> <span class="n">counter</span><span class="o">;</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Um thread pode chegar ao ponto de armazenar o <code>counter</code> em um local
temporário, mas depois fica sem tempo, permitindo que a próxima thread
agendada seja executada. Quando esse for o caso, a próxima thread poderá fazer uma série de
incrementos no <code>count</code> que são sobrescritos quando a primeira thread
for executada novamente. Como a primeira thread tinha um valor antigo de <code>counter</code>
armazenado em <code>temp</code>, adicionar 1 a <code>temp</code> tem o efeito de ignorar
os incrementos que ocorreram nesse intervalo. Essa situação pode ocorrer em um único
processador com threads alternando entre si, mas é ainda mais perigosa
em um sistema com vários núcleos.</p>
</div>
<div class="paragraph">
<p>A principal lição aqui é que as threads podem alternar entre si a
a qualquer momento, com efeitos imprevisíveis. A segunda lição é que o
código-fonte é muito grosseiro para mostrar operações <em>atômicas</em>. Uma operação atômica
atômica é aquela que não pode ser interrompida por uma troca de contexto para
outra thread. O código real que a JVM executa é de nível muito mais baixo
do que o código-fonte.</p>
</div>
<div class="paragraph">
<p>Não é possível forçar facilmente uma operação não atômica a ser atômica, mas existem
maneiras de restringir o acesso a determinadas partes do código sob certas
condições. O nome que damos a um trecho de código que não deve ser
acessado por mais de uma thread ao mesmo tempo é <em>seção crítica</em>. No
No exemplo acima, a única linha de código que incrementa o <code>counter</code> é
uma seção crítica, e o erro no programa seria removido se
apenas uma thread pudesse executar essa linha de código por vez.</p>
</div>
<div class="paragraph">
<p>A proteção de uma seção crítica é feita com ferramentas de <em>exclusão mútua</em>.
Elas são chamadas de ferramentas de exclusão mútua porque impõem o
requisito de que uma thread que executa uma seção crítica exclui a
possibilidade de outra. Há muitas técnicas, algoritmos
e recursos de linguagem na ciência da computação que podem ser usados para criar
exclusão mútua. O Java depende muito de uma ferramenta chamada <em>monitor</em> que
oculta do usuário alguns dos detalhes da aplicação da exclusão mútua.
A exclusão mútua é um tópico profundamente pesquisado com muitas abordagens além
além dos monitores. Se planeja escrever programas concorrentes em outra
linguagem, talvez seja necessário se atualizar sobre os recursos de exclusão
mútua dessa linguagem.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#restaurantSynchronizationExercise">[restaurantSynchronizationExercise]</a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sintaxe_sincronização_de_thread">14.4. Sintaxe: Sincronização de thread</h3>
<div class="sect3">
<h4 id="_a_palavra_chave_synchronized">14.4.1. A palavra-chave <code>synchronized</code></h4>
<div class="paragraph">
<p>Em Java, o recurso de linguagem que permite que você aplique a
exclusão mútua é a palavra-chave <code>synchronized</code>. Há duas maneiras de usar essa
palavra-chave: com um método ou com um bloco arbitrário de código. No método
você adiciona o modificador <code>synchronized</code> antes do tipo de retorno.
Vamos imaginar uma classe com um campo <code>String</code> privado chamado <code>message</code>
que é definido como <code>“Will Robinson!”</code> pelo construtor. Agora, definimos
o seguinte método.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">danger</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s">"Danger, "</span> <span class="o">+</span> <span class="n">message</span><span class="o">;</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Se <code>danger()</code> for chamada cinco vezes em diferentes threads, <code>message</code> conterá<br>
<code>“Perigo, Perigo, Perigo, Perigo, Perigo, Will Robinson!”</code>.
Sem a palavra-chave <code>synchronized</code>, <code>danger()</code> sofreria de uma condição de corrida
semelhante à de <code>RaceCondition</code>. Algumas das concatenações de <code>String</code>
podem ser sobrescritas por outras chamadas a <code>danger()</code>.
Você nunca teria mais de cinco cópias de <code>“Danger,”</code> anexadas ao
no início de <code>message</code>, mas você pode ter menos.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#synchronizedKeywordExercise">[synchronizedKeywordExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Sempre que uma thread entra em um trecho de código protegido pela palavra-chave
<code>synchronized</code> ele adquire implicitamente um bloqueio que somente uma única thread pode
manter. Se outra thread tentar acessar o código, ela será forçada a esperar
até que o bloqueio seja liberado. Esse bloqueio é <em>reentrante</em>. Reentrante significa
significa que, quando uma thread mantém um bloqueio e tenta obtê-lo novamente, ela
é bem-sucedida. Essa situação ocorre frequentemente com métodos sincronizados
que chamam outros métodos sincronizados.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#lockTimingExercise">[lockTimingExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Considere o método <code>safety()</code> que faz o “<code>oposto</code>” de <code>danger()</code>, removendo
as ocorrências de <code>“Danger,”</code> do início de <code>message</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">safety</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"Danger, "</span><span class="o">))</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Os métodos <code>danger()</code> e <code>safety()</code> funcionarão bem juntos no mesmo objeto? Em
outras palavras, uma thread será impedida de entrar em
<code>safety()</code> se outra thread já estiver em <code>danger()</code>? Sim! Os bloqueios
em Java estão conectados a objetos. Quando você usa a palavra-chave <code>synchronized</code> em um método
o objeto no qual o método está sendo chamado (qualquer que seja o objeto
<code>this</code> se refere dentro do método) funciona como o bloqueio. Portanto, somente uma
thread pode estar dentro de qualquer um desses métodos em um determinado objeto. Se você tiver 10
métodos sincronizados em um objeto, somente um deles poderá ser executado por vez para esse objeto.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#constructorLeakExercise">[constructorLeakExercise]</a><br>
<a href="chap14.html#synchronizedThreadIncrementExercise">[synchronizedThreadIncrementExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Talvez esse nível de controle seja muito restritivo. Você pode ter seis
métodos que entram em conflito entre si e outros quatro que entram em conflito
entre si, mas não com os seis primeiros. Usar <code>synchronized</code> em cada
declaração de método limitaria desnecessariamente a quantidade de
concorrência que seu programa poderia ter.</p>
</div>
<div class="paragraph">
<p>Embora exija um pouco mais de trabalho, o uso de <code>synchronized</code> em um bloco
de código permite um controle mais refinado. A seguinte versão de
<code>danger()</code> é equivalente à anterior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">danger</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Danger, "</span> <span class="o">+</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O uso de <code>synchronized</code> em um bloco de código nos dá mais flexibilidade de duas
maneiras. Primeiro, podemos escolher exatamente a quantidade de código que queremos controlar,
em vez de todo o método. Segundo, podemos escolher qual objeto queremos usar para
a sincronização. No estilo de bloco, qualquer objeto arbitrário
pode ser usado como um bloqueio. Os objetos mantêm uma lista de threads que estão esperando
para obter o bloqueio e fazem todos os outros gerenciamentos necessários para que a palavra-chave
<code>synchronized</code> funcione.</p>
</div>
<div class="paragraph">
<p>Se houver duas seções críticas que não estejam relacionadas entre si, você
poderá usar o controle refinado que o estilo de bloco oferece. Primeiro, você precisará
de alguns objetos para usar como bloqueios, provavelmente declarados de forma que possam ser
facilmente compartilhados, talvez como campos estáticos de uma classe.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">lock1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">lock2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Então, sempre que precisar de controle sobre a concorrência, use-os como bloqueios.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">synchronized</span><span class="o">(</span><span class="n">lock1</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Fazer coisas perigosas 1</span>
<span class="o">}</span>

<span class="c1">// Fazer coisas seguras</span>

<span class="kd">synchronized</span><span class="o">(</span><span class="n">lock2</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Fazer a coisa perigosa 2, não relacionada à coisa perigosa 1</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Como declarar um método com <code>synchronized</code> é equivalente a ter seu corpo
em um bloco que começa com <code>synchronized(this)</code>, o que dizer dos métodos
métodos <code>static</code>? Eles podem ser <code>sincronizados</code>? Sim, podem. Sempre que uma classe
é carregada, o Java cria um objeto do tipo <code>Class</code> que
corresponde a essa classe. Esse objeto é o que os métodos estáticos sincronizados
dentro da classe usarão como bloqueio. Por exemplo, um método
estático sincronizado dentro da classe <code>Eggplant</code> bloqueará o objeto
<code>Eggplant.class</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_os_métodos_wait_e_notify">14.4.2. Os métodos <code>wait()</code> e <code>notify()</code></h4>
<div class="paragraph">
<p>A proteção de seções críticas com a palavra-chave <code>synchronized</code> é uma
técnica poderosa, e muitas outras ferramentas de sincronização podem ser criadas
usando apenas essa ferramenta. Entretanto, a eficiência exige mais algumas opções.</p>
</div>
<div class="paragraph">
<p>Às vezes, uma thread está esperando que outra thread termine uma tarefa para
possa processar os resultados. Imagine uma thread coletando votos
enquanto outra está esperando para contá-los. Nesse exemplo, a thread de
contagem deve esperar que todos os votos sejam lançados antes de começar a
contar. Poderíamos usar um bloco sincronizado e um indicador <code>boolean</code>
chamado <code>votingComplete</code> para permitir que a thread do coletor sinalize para a thread de contagem.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">votingComplete</span><span class="o">)</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">countVotes</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Qual é o problema com esse design? A thread de contagem está
está executando o loop <code>while</code> repetidamente, esperando que
<code>votingComplete</code> se torne <code>true</code>. Em um único processador, a thread de contagem
retardaria o trabalho da thread de coleta que está tentando processar todos os votos.
Em um sistema com vários núcleos, a thread de contagem
ainda está desperdiçando ciclos de CPU que alguma outra thread poderia usar. Esse
fenômeno é conhecido como <em>busy waiting</em>, por motivos óbvios.</p>
</div>
<div class="paragraph">
<p>Para combater esse problema, o Java fornece o método <code>wait()</code>. Quando uma
thread está executando código sincronizado, ele pode chamar <code>wait()</code>. Em vez de ficar ocupada
esperando, uma thread que tenha chamado <code>wait()</code> será removida da lista de threads em execução.
Ele aguardará em um estado inativo até que alguém
apareça e notifique a thread de que sua espera terminou. Se você
lembrar do diagrama de estado da thread de <a href="chap13.html">Capítulo 13</a>,
há um estado <code>Not Runnable</code> no qual as threads entram ao
chamar <code>sleep()</code>, chamando <code>wait()</code> ou executando E/S de bloqueio. Usando
<code>wait()</code>, podemos reescrever a thread de contagem de votos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">votingComplete</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">wait</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">countVotes</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe que o loop <code>while</code> foi movido para dentro do bloco sincronizado.
Fazer isso antes poderia ter impedido o término do nosso programa:
Enquanto a thread de contagem de votos mantivesse o bloqueio, a thread de coleta de votos
não teria permissão para modificar <code>votingComplete</code>. Quando uma thread chama <code>wait()</code>,
no entanto, ele abre mão do bloqueio correspondente que está mantendo até que ela
acorde e execute novamente. Por que usar o loop <code>while</code> agora? Não há
garantia de que a condição que você está esperando é “verdadeira”. Muitas threads
podem estar esperando por esse bloqueio específico. Usamos o loop <code>while</code> para verificar
que <code>votingComplete</code> é <code>true</code> e esperamos <strong>novamente</strong> se não for.</p>
</div>
<div class="paragraph">
<p>Para notificar uma thread em espera, a outra thread chama o
método <code>notify()</code>. Assim como o <code>wait()</code>, o <code>notify()</code> deve ser chamado em um
bloco ou método sincronizado. Aqui está o código correspondente que a thread de coleta de votos
pode usar para notificar a thread de contagem de votos de que a votação foi
concluída.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="c1">// Finish collecting votes</span>
<span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">votingComplete</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">notifyAll</span><span class="o">();</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma chamada a <code>notify()</code> despertará uma thread que esteja aguardando o objeto de bloqueio.
Se houver muitas threads aguardando, o método <code>notifyAll()</code> usado acima
pode ser chamado para despertar todas elas. Na prática, geralmente é mais seguro
chamar <code>notifyAll()</code>. Se uma determinada condição for alterada e uma única
thread em espera for notificada, essa thread talvez precise notificar a próxima
thread em espera quando tiver terminado. Se seu código não for <strong>muito</strong>
cuidadosamente projetado, alguma thread pode acabar esperando para sempre e nunca ser notificada
se você depender apenas de <code>notify()</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#waitNotifyExercise">[waitNotifyExercise]</a><br>
<a href="chap14.html#notifyAllExercise">[notifyAllExercise]</a></p>
</div>
</div>
</div>
<div id="producerConsumerExample" class="exampleblock">
<div class="title">Exemplo 14.1 Producer/consumer</div>
<div class="content">
<div class="paragraph">
<p>To illustrate the use of <code>wait()</code> and <code>notify()</code> calls inside of
synchronized code, we give a simple solution to the producer/consumer
problem below. This problem is a classic example in the concurrent
programming world. Often one thread (or a group of threads) is
producing data, perhaps from some input operation. At the same time, one
thread (or, again, a group of threads) is taking these chunks of
data and consuming them by performing some computational or output task.</p>
</div>
<div class="paragraph">
<p>Every resource inside of a computer is finite. Producer/consumer
problems often assume a bounded buffer which stores items from the
producer until the consumer can take them away. Our solution does all
synchronization on this buffer. Many different threads can share this
buffer, but all accesses will be controlled.</p>
</div>
<div id="BufferProgram" class="listingblock">
<div class="title">Programa 14.2 Example of a synchronized buffer.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Buffer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="no">SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">SIZE</span><span class="o">];</span>    
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">while</span><span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="no">SIZE</span><span class="o">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="n">wait</span><span class="o">();</span>     
        <span class="n">objects</span><span class="o">[</span><span class="n">count</span><span class="o">]</span> <span class="o">=</span> <span class="n">object</span><span class="o">;</span>
        <span class="n">count</span><span class="o">++;</span>
        <span class="n">notifyAll</span><span class="o">();</span>         <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">Object</span> <span class="nf">removeItem</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="k">while</span><span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>    <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="n">wait</span><span class="o">();</span>
        <span class="n">count</span><span class="o">--;</span>
        <span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objects</span><span class="o">[</span><span class="n">count</span><span class="o">];</span>     
        <span class="n">notifyAll</span><span class="o">();</span>         <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="k">return</span> <span class="n">object</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When adding an item, producers enter the synchronized <code>addItem()</code>
method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If <code>count</code> shows that the buffer is full, the producer must wait
until the buffer has at least one open space.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>After adding an item to
the buffer, the producer then notifies all waiting threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The consumer
performs mirrored operations in <code>removeItem()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A consumer thread can’t
consume anything if the buffer is empty and must then wait.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>After there’s
an object to consume, the consumer removes it and notifies all other
threads.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Both methods are synchronized, making access to the buffer completely
sequential. Although it seems undesirable, sequential behavior is
precisely what’s needed for the producer/consumer problem. All
synchronized code is a protection against unsafe concurrency. The goal
is to minimize the amount of time spent in synchronized code and get
threads back to parallel execution as quickly as possible.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#twoLockProducerConsumerExercise">[twoLockProducerConsumerExercise]</a></p>
</div>
</div>
</div>
<div id="bankAccountExample" class="exampleblock">
<div class="title">Exemplo 14.2 Bank account</div>
<div class="content">
<div class="paragraph">
<p>Although producer/consumer is a good model to keep in mind, there are
other ways that reading and writing threads might interact. Consider the
following programming problem, similar to one you might find in real
life.</p>
</div>
<div class="paragraph">
<p>As a rising star in a bank’s IT department, you’ve been given the job
of creating a new bank account class called <code>SynchronizedAccount</code>. This
class must have methods to support the following operations: deposit,
withdraw, and check balance. Each method should print a status message
to the screen on completion. Also, the method for withdraw should return
<code>false</code> and do nothing if there are insufficient funds. Because the
latest system is multi-threaded, these methods must be designed so that
the bookkeeping is consistent even if many threads are accessing a
single account. No money should magically appear or disappear.</p>
</div>
<div class="paragraph">
<p>There’s an additional challenge. To maximize concurrency,
<code>SynchronizedAccount</code> should be synchronized differently for read and
write accesses. Any number of threads should be able to
check the balance on an account simultaneously, but only one thread can
deposit or withdraw at a time.</p>
</div>
<div class="paragraph">
<p>To solve this problem, our implementation of the class has a <code>balance</code>
variable to record the balance, but it also has a <code>readers</code> variable to
keep track of the number of threads which are reading from the account
at any given time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SynchronizedAccount</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">balance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>   
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    </code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, the <code>getBalance()</code> method is called by threads which wish to read
the balance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getBalance</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">amount</span><span class="o">;</span>      
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>   <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="n">readers</span><span class="o">++;</span>
        <span class="o">}</span>       
        <span class="n">amount</span> <span class="o">=</span> <span class="n">balance</span><span class="o">;</span>      <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(--</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
                <span class="n">notifyAll</span><span class="o">();</span>   <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="o">}</span>       
        <span class="k">return</span> <span class="n">amount</span><span class="o">;</span>      
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Access to the <code>readers</code> variable is synchronized.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>After passing that first <code>synchronized</code> block, the code which stores the
balance is no longer synchronized. In this way, multiple readers can access
the data at the same time. For this example, the concurrency controls we
have are overkill. The command <code>amount = balance</code> does not take a great
deal of time. If it did, however, it would make sense for readers to
execute it concurrently as we do.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>After reading the balance, this method
decrements <code>readers</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If <code>readers</code> reaches 0, a call to <code>notifyAll()</code> is
made, signaling that threads trying to deposit to or withdraw from the
account can continue.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="n">changeBalance</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deposited $"</span> <span class="o">+</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">"."</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">withdraw</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">success</span> <span class="o">=</span> <span class="n">changeBalance</span><span class="o">(-</span><span class="n">amount</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">success</span><span class="o">)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Withdrew $"</span> <span class="o">+</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">"."</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Failed to withdraw $"</span> <span class="o">+</span>
                <span class="n">amount</span> <span class="o">+</span> <span class="s">": insufficient funds."</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">success</span><span class="o">;</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>deposit()</code> and <code>withdraw()</code> methods are wrappers for the
<code>changeBalance()</code> method, which has all the interesting concurrency
controls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">protected</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">changeBalance</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">success</span><span class="o">;</span>    
        <span class="k">while</span><span class="o">(</span><span class="n">readers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
			<span class="n">wait</span><span class="o">();</span>         
        <span class="k">if</span><span class="o">(</span><span class="n">success</span> <span class="o">=</span> <span class="o">(</span><span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">))</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="n">balance</span> <span class="o">+=</span> <span class="n">amount</span><span class="o">;</span>      
        <span class="k">return</span> <span class="n">success</span><span class="o">;</span> 
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>changeBalance()</code> method is synchronized so that it can have
exclusive access to the <code>readers</code> variable. It’s also marked <code>protected</code>
because <code>SynchronizedAccount</code> will be used as a parent class in
<a href="chap17.html">Capítulo 17</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As long as <code>readers</code> is
greater than 0, this method will wait.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Eventually, the readers should
finish their job and notify the waiting writer which can finish changing
the balance of the account.</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_synchronization_challenges">14.5. Pitfalls: Synchronization challenges</h3>
<div class="paragraph">
<p>As you can see from the dining philosophers problem, synchronization
tools help us get the right answer but also create other difficulties.</p>
</div>
<div class="sect3">
<h4 id="_deadlock">14.5.1. Deadlock</h4>
<div class="paragraph">
<p><em>Deadlock</em> is the situation when two or more threads are both waiting
for the others to complete, forever. Some combination of locks or other
synchronization tools has forced a blocking dependence onto a group of
threads which will <strong>never</strong> be resolved.</p>
</div>
<div class="paragraph">
<p>In the past, people have described four conditions which must exist for
deadlock to happen.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mutual Exclusion: Only one thread can access the resource (often a
lock) at a time.</p>
</li>
<li>
<p>Hold and Wait: A thread holding a resource can ask for additional
resources.</p>
</li>
<li>
<p>No Preemption: A thread holding a resource cannot be forced to
release it by another thread.</p>
</li>
<li>
<p>Circular Wait: Two or more threads hold resources which make up a
circular chain of dependency.</p>
</li>
</ol>
</div>
<div id="deadlockPhilosophersExample" class="exampleblock">
<div class="title">Exemplo 14.3 Deadlock philosophers</div>
<div class="content">
<div class="paragraph">
<p>We illustrate deadlock with an example of how <strong>not</strong> to solve the dining
philosophers problem. What if all the philosophers decided to pick up
the chopstick on her left and then the chopstick on her right? If the
timing was just right, each philosopher would be holding one chopstick
in her left hand and be waiting forever for her neighbor on the right to
give up a chopstick. No philosopher would ever be able to eat. Here’s
that scenario illustrated in code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeadlockPhilosopher</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SEATS</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>     <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">chopsticks</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">SEATS</span><span class="o">];</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">seat</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">DeadlockPhilosopher</span><span class="o">(</span><span class="kt">int</span> <span class="n">seat</span><span class="o">)</span> <span class="o">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">this</span><span class="o">.</span><span class="na">seat</span> <span class="o">=</span> <span class="n">seat</span><span class="o">;</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a constant for the number of seats.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We create a shared <code>boolean</code> array called <code>chopsticks</code> so that all philosophers
can know which chopsticks are in use.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The constructor assigns each philosopher a seat number.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>        
        <span class="nc">DeadlockPhilosopher</span><span class="o">[]</span> <span class="n">philosophers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeadlockPhilosopher</span><span class="o">[</span><span class="no">SEATS</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SEATS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">philosophers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeadlockPhilosopher</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">philosophers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>    <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">}</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SEATS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>                        
                <span class="n">philosophers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>       
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"All philosophers done."</span><span class="o">);</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In <code>main()</code>, we create and start a thread for each
philosopher.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then, we wait for them to finish which, sadly, will never happen.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>After setting up the class and the <code>main()</code> method, things get interesting
in the <code>run()</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>         
        <span class="k">try</span> <span class="o">{</span> 
            <span class="n">getChopstick</span><span class="o">(</span><span class="n">seat</span><span class="o">);</span>     			<i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>       			<i class="conum" data-value="2"></i><b>(2)</b>
			<span class="n">getChopstick</span><span class="o">((</span><span class="n">seat</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">SEATS</span><span class="o">);</span> 	<i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>           
        <span class="n">eat</span><span class="o">();</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First a philosopher tries to get her left chopstick.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then she sleeps for 50 milliseconds.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, she tries to get her right chopstick. We mod by <code>SEATS</code> so that the
last philosopher will try to get the chopstick at the beginning of the array.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Without sleeping, this code would usually run just fine.
Every once in a while, the philosophers would become deadlocked, but it
would be hard to predict when. By introducing the sleep, we can all but
guarantee that the philosophers will deadlock every time.</p>
</div>
<div class="paragraph">
<p>The remaining two methods are worth examining to see how the
synchronization is done, but by getting the two chopsticks separately
above, we’ve already gotten ourselves into trouble.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">getChopstick</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">location</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="no">SEATS</span><span class="o">;</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">chopsticks</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span><span class="o">(</span><span class="n">chopsticks</span><span class="o">[</span><span class="n">location</span><span class="o">])</span>
                <span class="n">chopsticks</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
            <span class="n">chopsticks</span><span class="o">[</span><span class="n">location</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>       
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Philosopher "</span> <span class="o">+</span> <span class="n">seat</span> <span class="o">+</span>
            <span class="s">" picked up chopstick "</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s">"."</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Done eating, put back chopsticks</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">chopsticks</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">chopsticks</span><span class="o">[</span><span class="n">seat</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>           
            <span class="k">if</span><span class="o">(</span><span class="n">seat</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">chopsticks</span><span class="o">[</span><span class="no">SEATS</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">chopsticks</span><span class="o">[</span><span class="n">seat</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>                           
            <span class="n">chopsticks</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>    </code></pre>
</div>
</div>
</div>
</div>
<div id="deadlockSumExample" class="exampleblock">
<div class="title">Exemplo 14.4 Deadlock sum</div>
<div class="content">
<div class="paragraph">
<p>Here’s another example of deadlock. We emphasize deadlock because it’s
one of the most common and problematic issues with using synchronization
carelessly.</p>
</div>
<div class="paragraph">
<p>Consider two threads which both need access to two separate resources.
In our example, the two resources are random number generators. The goal
of each of these threads is to acquire locks for the two shared random
number generators, generate two random numbers each, and sum the numbers
generated. (Note that locks are totally unnecessary for this problem
since access to <code>Random</code> objects is synchronized.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeadlockSum</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Random</span> <span class="n">random1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Random</span> <span class="n">random2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>   
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">reverse</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The class begins by creating shared <code>static</code> <code>Random</code> objects
<code>random1</code> and <code>random2</code>. Then, in the <code>main()</code> method, the main thread
spawns two new threads, passing <code>true</code> to one and <code>false</code> to the other.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeadlockSum</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeadlockSum</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>                   
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, the mischief begins to unfold. One of the two threads stores
<code>true</code> in its <code>reverse</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="nf">DeadlockSum</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">reverse</span> <span class="o">=</span> <span class="n">reverse</span><span class="o">;</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we have the <code>run()</code> method where all the action happens. If the
two running threads were both to acquire locks for <code>random1</code> and <code>random2</code> in
the same order, everything would work out fine. However, the reversed
thread locks on <code>random2</code> and then <code>random1</code>, with a <code>sleep()</code> in
between. The non-reversed thread tries to lock on <code>random1</code> and then
<code>random2</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">if</span><span class="o">(</span><span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>         
            <span class="kd">synchronized</span><span class="o">(</span><span class="n">random2</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Reversed Thread: locked random2"</span><span class="o">);</span>
				<span class="k">try</span><span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span> <span class="o">}</span>
				<span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span>
				<span class="kd">synchronized</span><span class="o">(</span><span class="n">random1</span><span class="o">)</span> <span class="o">{</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Reversed Thread: locked random1"</span><span class="o">);</span>
					<span class="n">sum</span> <span class="o">=</span> <span class="n">random1</span><span class="o">.</span><span class="na">nextInt</span><span class="o">()</span> <span class="o">+</span> <span class="n">random2</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>                
				<span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>          
            <span class="kd">synchronized</span><span class="o">(</span><span class="n">random1</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Normal Thread: locked random1"</span><span class="o">);</span>
				<span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span> <span class="o">}</span>
				<span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
				  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span>
				<span class="kd">synchronized</span><span class="o">(</span><span class="n">random2</span><span class="o">)</span> <span class="o">{</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Normal Thread: locked random2"</span><span class="o">);</span>              
					<span class="n">sum</span> <span class="o">=</span> <span class="n">random1</span><span class="o">.</span><span class="na">nextInt</span><span class="o">()</span> <span class="o">+</span> <span class="n">random2</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>                
				<span class="o">}</span>
			<span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run this code, it should invariably deadlock with <code>thread1</code>
locked on <code>random2</code> and <code>thread2</code> locked on <code>random1</code>. No sane
programmer would intentionally code the threads like this. In fact, the
extra work we did to acquire the locks in opposite orders is exactly
what causes the deadlock. For more complicated programs, there may be
many different kinds of threads and many different resources. If two
different threads (perhaps written by different programmers) need
both resource A and resource B at the same time but try to acquire them
in reverse order, this kind of deadlock can occur without such an
obvious cause.</p>
</div>
<div class="paragraph">
<p>For deadlock of this type, the circular wait condition can be broken by
ordering the resources and always locking the resources in ascending
order. Of course, this solution only works if there is some universal
way of ordering the resources and the ordering is always followed by all
threads in the program.</p>
</div>
<div class="paragraph">
<p>Ignoring the deadlock problems with the example above, it gives a nice
example of the way Java intended synchronization to be done: when
possible, use the resource you need as its own lock. Many other
languages require programmers to create additional locks or semaphores
to protect a given resource, but this approach causes problems if the
same lock is not consistently used. Using the resource itself as a lock
is an elegant solution.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#deadlockExercise">[deadlockExercise]</a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_starvation_and_livelock">14.5.2. Starvation and livelock</h4>
<div class="paragraph">
<p><em>Starvation</em> is another problem which can occur with careless use of
synchronization tools. Starvation is a general term which covers any
situation in which some thread never gets access to the resources it
needs. Deadlock can be viewed as a special case of starvation since none
of the threads which are deadlocking makes progress.</p>
</div>
<div class="paragraph">
<p>The dining philosophers problem was framed around the idea of eating
with humorous intent. If a philosopher is never able to acquire
chopsticks, that philosopher will quite literally starve.</p>
</div>
<div class="paragraph">
<p>Starvation doesn’t necessarily mean deadlock, however. Examine the
implementation in <a href="chap14.html#bankAccountExample">Exemplo 14.2</a> for the bank account.
That solution is correct in the sense that it preserves mutual
exclusion. No combination of balance checks, deposits, or withdrawals
will cause the balance to be incorrect. Money will neither be created
nor destroyed. A closer inspection reveals that the solution is not
entirely fair. If a single thread is checking the balance, no other
thread can make a deposit or a withdrawal. Balance checking threads
could be coming and going constantly, incrementing and decrementing the
<code>readers</code> variable, but if <code>readers</code> never goes down to zero, threads
waiting to make deposits and withdrawals will wait forever.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#concurrentReadExercise">[concurrentReadExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Another kind of starvation is <em>livelock</em>. In deadlock, two or more
threads get stuck and wait forever, doing nothing. Livelock is similar
except that the two threads keep executing code and waiting for some
condition that never arrives. A classic example of livelock is two
polite (but oddly predictable) people speaking with each other:
Both happen to start talking at exactly the same moment and then stop to
hear what the other has to say. After exactly one second, they both
begin again and immediately stop. Lather, rinse, repeat.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 14.5 Livelock party preparations</div>
<div class="content">
<div class="paragraph">
<p>Imagine three friends going to a party. Each of them starts
getting ready at different times. They follow the pattern of getting
ready for a while, waiting for their friends to get ready, and then
calling their friends to see if the other two are ready. If all three
are ready, then the friends will leave. Unfortunately, if a friend calls
and either of the other two aren’t ready, he’ll become frustrated and
stop being ready. Perhaps he’ll realize that he’s got time to take a
shower or get involved in some other activity for a while. After
finishing that activity, he’ll become ready again and wait for his
friends to become ready.</p>
</div>
<div class="paragraph">
<p>If the timing is just right, the three friends will keep becoming ready,
waiting for a while, and then becoming frustrated when they realize that
their friends aren’t ready. Here’s a rough simulation of this process
in code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Livelock</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">totalReady</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 		   <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>   <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nc">Livelock</span> <span class="n">friend1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Livelock</span><span class="o">();</span>
        <span class="nc">Livelock</span> <span class="n">friend2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Livelock</span><span class="o">();</span>
        <span class="nc">Livelock</span> <span class="n">friend3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Livelock</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, we create a shared variable called <code>totalReady</code> which
tracks the total number of friends ready.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>To avoid race conditions, a shared <code>Object</code> called <code>lock</code> will be used to control
access to <code>totalReady</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then, the <code>main()</code> method creates <code>Livelock</code>
objects representing each of the friends.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">        <span class="k">try</span> <span class="o">{</span>       
            <span class="n">friend1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
            <span class="n">friend2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
            <span class="n">friend3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
                        
            <span class="n">friend1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">friend2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">friend3</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>       
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"All ready!"</span><span class="o">);</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The rest of the <code>main()</code> method starts each of the threads representing
the friends running, with a 100 millisecond delay before the next thread
starts . Then, it waits for them all to finish. If
successful, it’ll print <code>All ready!</code> to the screen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    
        <span class="k">try</span> <span class="o">{</span>       
            <span class="k">while</span><span class="o">(!</span><span class="n">done</span><span class="o">)</span> <span class="o">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">75</span><span class="o">);</span> <span class="c1">// Prepare for party </span><i class="conum" data-value="2"></i><b>(2)</b>
                <span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">totalReady</span><span class="o">++;</span>       <i class="conum" data-value="3"></i><b>(3)</b>
                <span class="o">}</span>                   
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">75</span><span class="o">);</span> <span class="c1">// Wait for friends  </span><i class="conum" data-value="4"></i><b>(4)</b>
                <span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">totalReady</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
                        <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">else</span>
                        <span class="n">totalReady</span><span class="o">--;</span>   <i class="conum" data-value="6"></i><b>(6)</b>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In the <code>run()</code> method, each friend goes through a loop until the <code>done</code>
variable is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In this loop, an initial call to <code>Thread.sleep()</code>
for 75 milliseconds represents preparing for the party.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>After that,
<code>totalReady</code> is incremented by one.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Then, the friend waits for another
75 milliseconds.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Finally, he checks to see if everyone else is ready by
testing whether <code>totalReady</code> is <code>3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>If not, he decrements <code>totalReady</code> and repeats the process.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>At roughly 75 milliseconds into the simulation, the first friend becomes
ready, but he doesn’t check with his friends until 150 milliseconds.
Unfortunately, the second friend doesn’t become ready until 175
milliseconds. He then checks with his friends at 225 milliseconds,
around which time the first friend is becoming ready a second time.
However, the third friend isn’t ready until 275 milliseconds. When he
then checks at 350 milliseconds, the first friend isn’t ready anymore.
On some systems the timing might drift such that the friends all become
ready at the same time, but it could take a long, long while.</p>
</div>
<div class="paragraph">
<p>In reality, human beings would not put off going to a party
indefinitely. Some people would decide that it was too late to go.
Others would go alone. Others would go over to their friends' houses and
demand to know what was taking so long. Computers are not nearly as
sensible and must obey instructions, even if they cause useless
repetitive patterns. Realistic examples of livelock are hard to show in
a short amount of code, but they do crop up in real systems and can be
very difficult to predict.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sequential_execution">14.5.3. Sequential execution</h4>
<div class="paragraph">
<p>When designing a parallel program, you might notice that synchronization
tools are necessary to get a correct answer. Then, when you run this
parallel version and compare it to the sequential version, it runs no
faster or, worse, runs slower than the sequential version. Too much zeal
with synchronization tools can produce a program which gives the right
answer but doesn’t exploit any parallelism.</p>
</div>
<div class="paragraph">
<p>For example, we can take the <code>run()</code> method from the parallel
implementation of matrix multiply given in <a href="chap13.html#matrixMultiplicationExample">Exemplo 13.11</a>
and use the <code>synchronized</code> keyword to lock on the matrix itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, only a single thread would have access to the matrix at
any given time, and all speedup would be lost.</p>
</div>
<div class="paragraph">
<p>For the parallel version of matrix multiply we gave earlier, no synchronization is needed. In
the case of the producer/consumer problem, synchronization is necessary,
and the only way to manage the buffer properly is to enforce sequential
execution. Sometimes sequential execution can’t be avoided, but you
should always know which pieces of code are truly executing in parallel
and which aren’t if you hope to get the maximum amount of speedup. The
<code>synchronized</code> keyword should be used whenever it’s needed, but no
more.</p>
</div>
</div>
<div class="sect3">
<h4 id="_priority_inversion">14.5.4. Priority inversion</h4>
<div class="paragraph">
<p>In <a href="chap13.html">Capítulo 13</a> we suggest that you rarely use
thread priorities. Even good reasons to use priorities can be
thwarted by <em>priority inversion</em>. In priority inversion, a lower
priority thread holds a lock needed by a higher priority thread,
potentially for a long time. Because the high priority thread cannot
continue, the lower priority thread gets more CPU time, as if it were a
high priority thread.</p>
</div>
<div class="paragraph">
<p>Worse, if there are some medium priority threads in the system, the low
priority thread could hold the lock needed by the high priority thread for
even longer because those medium priority threads reduce the amount of
CPU time the low priority thread has to finish its task.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#priorityInversionExercise">[priorityInversionExercise]</a><br>
<a href="chap14.html#priorityiInversionExperimentExercise">[priorityiInversionExperimentExercise]</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_solution_dining_philosophers">14.6. Solution: Dining philosophers</h3>
<div class="paragraph">
<p>Here we give our solution to the dining philosophers problem. Although
deadlock was the key pitfall we were trying to avoid, many other issues
can crop up in solutions to this problem. A single philosopher might be
forced into starvation, or all philosophers might experience livelock
through some pattern of picking up and putting down chopsticks which
never quite works out. A very simple solution could allow the
philosophers to eat, one by one, in order. Then, the philosophers would
often and unnecessarily be waiting to eat, and the program would
approach sequential execution.</p>
</div>
<div class="paragraph">
<p>The key element that makes our solution work is that we force a
philosopher to pick up two chopsticks atomically. The philosopher will
either pick up both chopsticks or neither.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiningPhilosopher</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SEATS</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span> 
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">chopsticks</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">SEATS</span><span class="o">];</span>   
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">seat</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">DiningPhilosopher</span><span class="o">(</span><span class="kt">int</span> <span class="n">seat</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">seat</span> <span class="o">=</span> <span class="n">seat</span><span class="o">;</span>       
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We begin with a similar setup as the deadlocking version given in
<a href="chap14.html#deadlockPhilosophersExample">Exemplo 14.3</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>        
        <span class="nc">DiningPhilosopher</span><span class="o">[]</span> <span class="n">philosophers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DiningPhilosopher</span><span class="o">[</span><span class="no">SEATS</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SEATS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">philosophers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DiningPhilosopher</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">philosophers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>    <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">}</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SEATS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>                        
                <span class="n">philosophers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>       
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"All philosophers done."</span><span class="o">);</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In <code>main()</code>, we create and start a thread for each
philosopher.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then, we wait for them to finish.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>               	<i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>	<i class="conum" data-value="2"></i><b>(2)</b>
            <span class="n">think</span><span class="o">();</span>				   
            <span class="n">getChopsticks</span><span class="o">();</span>           
            <span class="n">eat</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">think</span><span class="o">()</span> <span class="o">{</span>			  	<i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">sleep</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This <code>run()</code> method is different from the deadlocking version but not in
a way that prevents deadlock.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We added the <code>for</code> loop so that you could
see the philosophers eat and think many different times without
problems.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We also added the <code>think()</code> method to randomize the amount of
time between eating so that each run of the program is less
deterministic.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">getChopsticks</span><span class="o">()</span> <span class="o">{</span>	  	<i class="conum" data-value="1"></i><b>(1)</b>
        <span class="kt">int</span> <span class="n">location1</span> <span class="o">=</span> <span class="n">seat</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">location2</span> <span class="o">=</span> <span class="o">(</span><span class="n">seat</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="no">SEATS</span><span class="o">;</span>              
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">chopsticks</span><span class="o">)</span> <span class="o">{</span>	  	<i class="conum" data-value="2"></i><b>(2)</b>
            <span class="k">while</span><span class="o">(</span><span class="n">chopsticks</span><span class="o">[</span><span class="n">location1</span><span class="o">]</span> <span class="o">||</span> <span class="n">chopsticks</span><span class="o">[</span><span class="n">location2</span><span class="o">])</span> <span class="o">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">chopsticks</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>	<i class="conum" data-value="4"></i><b>(4)</b>
                <span class="o">}</span>
                <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>                               
            <span class="o">}</span>           
            <span class="n">chopsticks</span><span class="o">[</span><span class="n">location1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">chopsticks</span><span class="o">[</span><span class="n">location2</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>       
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Philosopher "</span> <span class="o">+</span> <span class="n">seat</span> <span class="o">+</span> <span class="s">" picked up chopsticks "</span> <span class="o">+</span>
			<span class="n">location1</span> <span class="o">+</span> <span class="s">" and "</span> <span class="o">+</span> <span class="n">location2</span> <span class="o">+</span> <span class="s">"."</span><span class="o">);</span>
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The real place where deadlock is prevented is in the <code>getChopsticks()</code>
method. As in <a href="chap14.html#deadlockPhilosophersExample">Exemplo 14.3</a>, we mod by <code>SEATS</code> so that the last philosopher
tries to get the first chopstick in the array.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The philosopher acquires the <code>chopsticks</code> lock.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then, she picks up the two chopsticks she needs only if both are available.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Otherwise, she waits.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span> 			  	<i class="conum" data-value="1"></i><b>(1)</b>
        <span class="c1">// Done eating, put back chopsticks</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">chopsticks</span><span class="o">)</span> <span class="o">{</span>	  	<i class="conum" data-value="2"></i><b>(2)</b>
            <span class="n">chopsticks</span><span class="o">[</span><span class="n">seat</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>           
            <span class="k">if</span><span class="o">(</span><span class="n">seat</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">chopsticks</span><span class="o">[</span><span class="no">SEATS</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">chopsticks</span><span class="o">[</span><span class="n">seat</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>               
            <span class="n">chopsticks</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>   	<i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Finally, in the <code>eat()</code> method, the philosopher eats the rice. We would
assume that some other computation would be done here in a realistic
problem <strong>before</strong> entering the <code>synchronized</code> block. The eating itself
does not require a lock.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>After eating’s done, the lock is acquired to
give back the chopsticks (hopefully after some cleaning).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then, all waiting philosophers are notified that some chopsticks may have become
available.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Our solution prevents deadlock and livelock because <strong>some</strong> philosopher
will get control of two chopsticks eventually, yet there are still
issues. Note that each philosopher only eats and thinks 100 times. If,
instead of philosophers sharing chopsticks, each thread were a server
sharing network storage units, the program could run for an unspecified
amount of time: days, weeks, even years. If starvation is happening to a
particular philosopher in our program, the other philosophers will
finish after 100 rounds, and the starved philosopher can catch up. If
there were no limitation on the loop, a starving philosopher might never
catch up.</p>
</div>
<div class="paragraph">
<p>Even if we increase the number of iterations of the loop quite a lot,
we probably wouldn’t see starvation of an individual thread because we’re
cheating in another way. Some unlucky sequence of chopstick accesses
by two neighboring philosophers could starve the philosopher between
them. By making the <code>think()</code> method wait a random amount of time, such
a sequence will probably be interrupted. If all philosophers thought for
exactly the same amount of time each turn, an unlucky pattern could
repeat. It’s not unreasonable to believe that the amount
of thinking a philosopher (or a server) will do at any given time will
vary, but the behavior depends on the system.</p>
</div>
<div class="paragraph">
<p>It’s very difficult to come up with a perfect answer to some
synchronization problems. Such problems have been studied for many
years, and research continues to find better solutions.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap14.html#fairDiningPhilosophersExercise">[fairDiningPhilosophersExercise]</a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_13">14.7. Exercises</h3>
<div class="paragraph">
<p><strong>Conceptual Problems</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="synchronizedKeywordExercise"></a> What’s the purpose of the
<code>synchronized</code> keyword? How does it work?</p>
</li>
<li>
<p><a id="constructorLeakExercise"></a> The language specification for Java
makes it illegal to use the <code>synchronized</code> keyword on constructors.
During the creation of an object, it’s possible to <em>leak</em> data to the
outside world by adding a reference to the object under construction to
some shared data structure. What’s the danger of leaking data in this
way?</p>
</li>
<li>
<p><a id="waitNotifyExercise"></a> If you call
<code>wait()</code> or <code>notify()</code> on an object, it <strong>must</strong> be inside of a block
synchronized on the same object. If not, the code will compile, but an
<code>IllegalMonitorStateException</code> may be thrown at run time. Why is it
necessary to own the lock on an object before calling <code>wait()</code> or
<code>notify()</code> on it?</p>
</li>
<li>
<p><a id="notifyAllExercise"></a> Why is it safer to call
<code>notifyAll()</code> than <code>notify()</code>? If it’s generally safer to call
<code>notifyAll()</code>, are there any scenarios in which there are good reasons
to call <code>notify()</code>?</p>
</li>
<li>
<p><a id="restaurantSynchronizationExercise"></a> Imagine a simulation of a
restaurant with many waiter and chef objects. The waiters must submit
orders to the kitchen staff, and the chefs must divide the work among
themselves. How would you design this system? How would information and
food be passed from waiter to chef and chef to waiter? How would you
synchronize the process?</p>
</li>
<li>
<p><a id="raceConditionExercise"></a> What’s a race condition? Give a real
life example of one.</p>
</li>
<li>
<p><a id="synchronizedThreadIncrementExercise"></a> Let’s reexamine the code that
increments a variable with several threads from
<a href="#Concepts: Thread interaction" class="target-missing">[Concepts: Thread interaction]</a>. We can rewrite the <code>run()</code>
method as follows.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">COUNT</span><span class="o">/</span><span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">counter</span><span class="o">++;</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Will this change fix the race condition? Why or why not?</p>
</div>
</li>
<li>
<p><a id="deadlockExercise"></a> Examine our deadlock example from
<a href="chap14.html#deadlockSumExample">Exemplo 14.4</a>. Explain why this example fulfills all
four conditions for deadlock. Be specific about which threads and which
resources are needed to show each condition.</p>
</li>
<li>
<p><a id="priorityInversionExercise"></a> What’s priority inversion? Why can
a low priority thread holding a lock be particularly problematic?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Programming Practice</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="twoLockProducerConsumerExercise"></a> In
<a href="chap14.html#producerConsumerExample">Exemplo 14.1</a> the <code>Buffer</code> class used to
implement a solution to the producer/consumer problem only has a single
lock. When the buffer is empty and a producer puts an item in it, both
producers and consumers are woken up. A similar situation happens
whenever the buffer is full and a consumer removes an item. Re-implement
this solution with two locks so that a producer putting an item into an
empty buffer only wakes up consumers and a consumer removing an item
from a full buffer only wakes up producers.</p>
</li>
<li>
<p><a id="concurrentReadExercise"></a> In <a href="chap14.html#bankAccountExample">Exemplo 14.2</a>
we used the class <code>SynchronizedAccount</code> to solve a bank account problem.
As we mention in <a href="chap14.html#_starvation_and_livelock">Seção 14.5.2</a>, depositing
and withdrawing threads can be starved out by a steady supply of balance
checking threads. Add additional synchronization tools to
<code>SynchronizedAccount</code> so that balance checking threads will take turns
with depositing and withdrawing threads. If there are no depositing or
withdrawing threads, make your implementation continue to allow an
unlimited number of balance checking threads to read concurrently.</p>
</li>
<li>
<p><a id="fairDiningPhilosophersExercise"></a> The solution to the dining
philosophers problem given in <a href="chap14.html#_solution_dining_philosophers">Seção 14.6</a>
suffers from the problem that a philosopher could be starved by the two
philosophers on either side of her, if she happened to get unlucky. Add
variables to each philosopher which indicate hunger and the last time a
philosopher has eaten. If a given philosopher is hungry and hasn’t
eaten for longer than her neighbor, her neighbor shouldn’t pick up the
chopstick they share. Add synchronization tools to enforce this
principle of fairness. Note that your solution must not cause
deadlock. Although one philosopher may be waiting on another who is
waiting on another and so on, <strong>some</strong> philosopher in the circle must have
gone hungry the longest, breaking circular wait.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Experiments</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="lockTimingExercise"></a> Critical sections can slow down
your program by preventing parallel computation. However, the locks used
to enforce critical sections can add extra delays on top of that. Design
a simple experiment which repeatedly acquires a lock and does some
simple operation. Test the running time with and without the lock. See
if you can estimate the time needed to acquire a lock in Java on your
system.</p>
</li>
<li>
<p><a id="threadTimeSliceExercise"></a> Design a program which
experimentally determines how much time a thread is scheduled to spend
running on a CPU before switching to the next thread. To do this, first
create a tight loop which runs a large number of iterations, perhaps
1,000,000 or more. Determine how much time it takes to run a single run
of those iterations. Then, write an outer loop which runs the tight loop
several times. Each iteration of the outer loop, test to see how much
time has passed. When you encounter a large jump in time, typically at
least 10 times the amount of time the tight loop usually takes to run to
completion, record that time. If you run these loops in multiple threads
and average the unusually long times together for each thread, you
should be able to find out about how long each thread waits between
runs. Using this information, you can estimate how much time each thread
is allotted. Bear in mind that your this average is only an estimation. Some JVMs
will change the amount of CPU time allotted to threads for various
reasons. If you’re on a multicore machine, it will be more difficult to
interpret your data since some threads will be running concurrently.</p>
</li>
<li>
<p><a id="priorityiInversionExperimentExercise"></a> Create an experiment to
investigate priority inversion in the following way.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Create two threads, setting the priority of the first to
<code>MIN_PRIORITY</code> and the priority of the second to <code>MAX_PRIORITY</code>. Start
the first thread running but wait 100 milliseconds before starting the
second thread. The first thread should acquire a shared lock and then
perform some lengthy process such as finding the sum of the sines of the
first million integers. After it finishes its computation, it should
release the lock, and print a message. The second thread should try to
acquire the lock, print a message, and then release the lock. Time the
process. Because the lock is held by the lower priority thread, the
higher priority thread will have to wait until the other thread is done
for it to finish.</p>
</li>
<li>
<p>Once you have a feel for the time it takes for these two threads to
finish alone, create 10 more threads that must also perform a lot of
computation. However, do not make these threads try to acquire the lock. How
much do they delay completion of the task? How does this delay relate to
the number of cores in your processor? How much does the delay change if
you set the priorities of these new threads to <code>MAX_PRIORITY</code> or
<code>MIN_PRIORITY</code>?</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
</div></div>

<nav>
  <a rel="prev" href="chap13.html" class="nav nav-prev" title="Previous page" aria-label="Previous page" aria-keyshortcuts="Left">
        <i class="fa fa-angle-left"></i>
     </a>
  <a rel="next" href="chap15.html" class="nav nav-next" title="Next page" aria-label="Next page" aria-keyshortcuts="Right">
        <i class="fa fa-angle-right"></i>
     </a>
  <div style="clear: both"></div>
</nav>
<div id="footer">
<div id="footer-text">
Last updated 2024-05-31 14:13:43 -0300
</div>
</div>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VEDGKRPMMK"></script>
          <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-VEDGKRPMMK');
          </script>

</body>
  <script>
  function isInViewport(ele) {
    const rect = ele.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    );
  }
  function yPosition (ele) {
    const rect = ele.getBoundingClientRect();
    return (rect.top - 20); // 20px above
  }
  let curr = document.getElementsByClassName('current');
  if (!isInViewport(curr[curr.length - 1])) {
    document.getElementById('toc').scrollTo({
      top: yPosition(curr[0]),
      left: 0,
      behavior: 'smooth'
    });
  }

  /* For page navigation */
  function gotoPage(selector) {
    const button = document.querySelector(selector);
    if (button)
      window.location.href = button.href;
  }
  document.addEventListener('keydown', e => {
    if (e.shiftKey)
      return;
    switch (e.key) {
      case 'ArrowRight':
        e.preventDefault();
        gotoPage('.nav-next');
        break;
      case 'ArrowLeft':
        e.preventDefault();
        gotoPage('.nav-prev');
        break;
    }
  });
  </script>
  </html>