<!DOCTYPE html><html lang="pt_BR"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<meta name="author" content="Barry Wittman, Tim Korb, Aditya Mathur">
<title>Começando Concorrente: Uma Introdução Gentil à Programação Concorrente</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="style0.css" type="text/css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="style1.css" type="text/css">
<link rel="stylesheet" href="asciidoctor-chunker.css" type="text/css"></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Começando Concorrente: Uma Introdução Gentil à Programação Concorrente</h1>
<div class="details">
<span id="author" class="author">Barry Wittman</span><br>
<span id="email" class="email"><a href="mailto:wittman1@otterbein.edu">wittman1@otterbein.edu</a></span><br>
<span id="author2" class="author">Tim Korb</span><br>
<span id="email2" class="email"><a href="mailto:jtk@purdue.edu">jtk@purdue.edu</a></span><br>
<span id="author3" class="author">Aditya Mathur</span><br>
<span id="email3" class="email"><a href="mailto:apm@purdue.edu">apm@purdue.edu</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<ul class="sectlevel1">
<li><a href="index.html">Começando Concorrente</a></li><li><a href="index.html">1. Computer Basics</a>
<ul class="sectlevel2">
<li><a href="index.html#_problem_buying_a_computer">1.1. Problem: Buying a computer</a></li>
<li><a href="index.html#_concepts_hardware_and_software">1.2. Concepts: Hardware and software</a></li>
<li><a href="index.html#_syntax_data_representation">1.3. Syntax: Data representation</a></li>
<li><a href="index.html#_solution_buying_a_computer">1.4. Solution: Buying a computer</a></li>
<li><a href="index.html#_summary">1.5. Summary</a></li>
<li><a href="index.html#_exercises">1.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap2.html">2. Problem Solving and Programming</a>
<ul class="sectlevel2">
<li><a href="chap2.html#_problem_how_to_solve_problems">2.1. Problem: How to solve problems</a></li>
<li><a href="chap2.html#_concepts_developing_software">2.2. Concepts: Developing software</a></li>
<li><a href="chap2.html#_syntax_java_basics">2.3. Syntax: Java basics</a></li>
<li><a href="chap2.html#_solution_how_to_solve_problems">2.4. Solution: How to solve problems</a></li>
<li><a href="chap2.html#_concurrency_solving_problems_in_parallel">2.5. Concurrency: Solving problems in parallel</a></li>
<li><a href="chap2.html#_summary_2">2.6. Summary</a></li>
<li><a href="chap2.html#_exercises_2">2.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap3.html">3. Primitive Types and Strings</a>
<ul class="sectlevel2">
<li><a href="chap3.html#_problem_college_cost_calculator">3.1. Problem: College cost calculator</a></li>
<li><a href="chap3.html#_concepts_types">3.2. Concepts: Types</a></li>
<li><a href="chap3.html#_syntax_types_in_java">3.3. Syntax: Types in Java</a></li>
<li><a href="chap3.html#_syntax_useful_libraries">3.4. Syntax: Useful libraries</a></li>
<li><a href="chap3.html#_solution_college_cost_calculator">3.5. Solution: College cost calculator</a></li>
<li><a href="chap3.html#_concurrency_expressions">3.6. Concurrency: Expressions</a></li>
<li><a href="chap3.html#_summary_3">3.7. Summary</a></li>
<li><a href="chap3.html#_exercises_3">3.8. Exercises</a></li>
</ul>
</li>
<li><a href="chap4.html">4. Selection</a>
<ul class="sectlevel2">
<li><a href="chap4.html#_problem_monty_hall_simulation">4.1. Problem: Monty Hall simulation</a></li>
<li><a href="chap4.html#_concepts_choosing_between_options">4.2. Concepts: Choosing between options</a></li>
<li><a href="chap4.html#_syntax_selection_in_java">4.3. Syntax: Selection in Java</a></li>
<li><a href="chap4.html#_solution_monty_hall">4.4. Solution: Monty Hall</a></li>
<li><a href="chap4.html#_concurrency_selection">4.5. Concurrency: Selection</a></li>
<li><a href="chap4.html#_exercises_4">4.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap5.html">5. Repetition</a>
<ul class="sectlevel2">
<li><a href="chap5.html#_problem_dna_searching">5.1. Problem: DNA searching</a></li>
<li><a href="chap5.html#_concepts_repetition">5.2. Concepts: Repetition</a></li>
<li><a href="chap5.html#_syntax_loops_in_java">5.3. Syntax: Loops in Java</a></li>
<li><a href="chap5.html#_solution_dna_searching">5.4. Solution: DNA searching</a></li>
<li><a href="chap5.html#_concurrency_loops">5.5. Concurrency: Loops</a></li>
<li><a href="chap5.html#_exercises_5">5.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap6.html">6. Arrays</a>
<ul class="sectlevel2">
<li><a href="chap6.html#_introduction">6.1. Introduction</a></li>
<li><a href="chap6.html#_problem_game_of_life">6.2. Problem: Game of Life</a></li>
<li><a href="chap6.html#_concepts_lists_of_data">6.3. Concepts: Lists of data</a></li>
<li><a href="chap6.html#_syntax_arrays_in_java">6.4. Syntax: Arrays in Java</a></li>
<li><a href="chap6.html#_examples_array_usage">6.5. Examples: Array usage</a></li>
<li><a href="chap6.html#_concepts_multidimensional_lists">6.6. Concepts: Multidimensional lists</a></li>
<li><a href="chap6.html#_syntax_advanced_arrays_in_java">6.7. Syntax: Advanced arrays in Java</a></li>
<li><a href="chap6.html#_examples_two_dimensional_arrays">6.8. Examples: Two-dimensional arrays</a></li>
<li><a href="chap6.html#_advanced_special_array_tools_in_java">6.9. Advanced: Special array tools in Java</a></li>
<li><a href="chap6.html#_solution_game_of_life">6.10. Solution: Game of Life</a></li>
<li><a href="chap6.html#_concurrency_arrays">6.11. Concurrency: Arrays</a></li>
<li><a href="chap6.html#_exercises_6">6.12. Exercises</a></li>
</ul>
</li>
<li><a href="chap7.html">7. Simple Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap7.html#_problem_codon_extractor">7.1. Problem: Codon extractor</a></li>
<li><a href="chap7.html#GUIBasicsIntroductionSection">7.2. Concepts: User interaction</a></li>
<li><a href="chap7.html#_syntax_dialogs_and_the_joptionpane_class">7.3. Syntax: Dialogs and the <code>JOptionPane</code> class</a></li>
<li><a href="chap7.html#_solution_codon_extractor">7.4. Solution: Codon extractor</a></li>
<li><a href="chap7.html#_concurrency_simple_guis">7.5. Concurrency: Simple GUIs</a></li>
<li><a href="chap7.html#_summary_4">7.6. Summary</a></li>
<li><a href="chap7.html#_exercises_7">7.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap8.html">8. Methods</a>
<ul class="sectlevel2">
<li><a href="chap8.html#_problem_three_card_poker">8.1. Problem: Three card poker</a></li>
<li><a href="chap8.html#_concepts_dividing_work_into_segments">8.2. Concepts: Dividing work into segments</a></li>
<li><a href="chap8.html#_syntax_methods">8.3. Syntax: Methods</a></li>
<li><a href="chap8.html#_examples_defining_methods">8.4. Examples: Defining methods</a></li>
<li><a href="chap8.html#_solution_three_card_poker">8.5. Solution: Three card poker</a></li>
<li><a href="chap8.html#_concurrency_methods">8.6. Concurrency: Methods</a></li>
<li><a href="chap8.html#_exercises_8">8.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap9.html">9. Classes</a>
<ul class="sectlevel2">
<li><a href="chap9.html#_problem_nested_expressions">9.1. Problem: Nested expressions</a></li>
<li><a href="chap9.html#_concepts_object_oriented_programming">9.2. Concepts: Object-oriented programming</a></li>
<li><a href="chap9.html#_syntax_classes_in_java">9.3. Syntax: Classes in Java</a></li>
<li><a href="chap9.html#_advanced_nested_classes">9.4. Advanced: Nested classes</a></li>
<li><a href="chap9.html#_solution_nested_expressions">9.5. Solution: Nested expressions</a></li>
<li><a href="chap9.html#_concurrency_objects">9.6. Concurrency: Objects</a></li>
<li><a href="chap9.html#_exercises_9">9.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap10.html">10. Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap10.html#_problem_sort_it_out">10.1. Problem: Sort it out</a></li>
<li><a href="chap10.html#_concepts_making_a_promise">10.2. Concepts: Making a promise</a></li>
<li><a href="chap10.html#_syntax_interfaces">10.3. Syntax: Interfaces</a></li>
<li><a href="chap10.html#_advanced_local_and_anonymous_classes">10.4. Advanced: Local and anonymous classes</a></li>
<li><a href="chap10.html#_solution_sort_it_out">10.5. Solution: Sort it out</a></li>
<li><a href="chap10.html#_concurrency_interfaces">10.6. Concurrency: Interfaces</a></li>
<li><a href="chap10.html#_exercises_10">10.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap11.html">11. Inheritance</a>
<ul class="sectlevel2">
<li><a href="chap11.html#_problem_boolean_circuits">11.1. Problem: Boolean circuits</a></li>
<li><a href="chap11.html#_concepts_refining_classes">11.2. Concepts: Refining classes</a></li>
<li><a href="chap11.html#_syntax_inheritance_in_java">11.3. Syntax: Inheritance in Java</a></li>
<li><a href="chap11.html#_examples_problem_solving_with_inheritance">11.4. Examples: Problem solving with inheritance</a></li>
<li><a href="chap11.html#_solution_boolean_circuits">11.5. Solution: Boolean circuits</a></li>
<li><a href="chap11.html#_concurrency_inheritance">11.6. Concurrency: Inheritance</a></li>
<li><a href="chap11.html#_exercises_11">11.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap12.html">12. Exceptions</a>
<ul class="sectlevel2">
<li><a href="chap12.html#_problem_bank_burglary">12.1. Problem: Bank burglary</a></li>
<li><a href="chap12.html#_concepts_error_handling">12.2. Concepts: Error handling</a></li>
<li><a href="chap12.html#_syntax_exceptions_in_java">12.3. Syntax: Exceptions in Java</a></li>
<li><a href="chap12.html#_solution_bank_burglary">12.4. Solution: Bank burglary</a></li>
<li><a href="chap12.html#_concurrency_exceptions">12.5. Concurrency: Exceptions</a></li>
<li><a href="chap12.html#_exercises_12">12.6. Exercises</a></li>
</ul>
</li>
<li class="current"><a href="chap13.html">13. Programação Concorrente</a>
<ul class="sectlevel2">
<li class="current"><a href="chap13.html#_introdução">13.1. Introdução</a></li>
<li class="current"><a href="chap13.html#_problema_vírus_mortal">13.2. Problema: Vírus mortal</a></li>
<li class="current"><a href="chap13.html#_conceitos_dividindo_para_conquistar">13.3. Conceitos: Dividindo para conquistar</a></li>
<li class="current"><a href="chap13.html#_sintaxe_threads_em_java">13.4. Sintaxe: Threads em Java</a></li>
<li class="current"><a href="chap13.html#_exemplos_concorrência_e_aceleração">13.5. Exemplos: Concorrência e aceleração</a></li>
<li class="current"><a href="chap13.html#_conteitos_agendamento_de_thread">13.6. Conteitos: Agendamento de thread</a></li>
<li class="current"><a href="chap13.html#_sintaxe_estados_da_thread">13.7. Sintaxe: Estados da thread</a></li>
<li class="current"><a href="chap13.html#_solução_vírus_mortal">13.8. Solução: Vírus mortal</a></li>
<li class="current"><a href="chap13.html#_resumo">13.9. Resumo</a></li>
<li class="current"><a href="chap13.html#_exercícios">13.10. Exercícios</a></li>
</ul>
</li>
<li><a href="chap14.html">14. Synchronization</a>
<ul class="sectlevel2">
<li><a href="chap14.html#_introduction_2">14.1. Introduction</a></li>
<li><a href="chap14.html#_problem_dining_philosophers">14.2. Problem: Dining philosophers</a></li>
<li><a href="chap14.html#_concepts_thread_interaction">14.3. Concepts: Thread interaction</a></li>
<li><a href="chap14.html#_syntax_thread_synchronization">14.4. Syntax: Thread synchronization</a></li>
<li><a href="chap14.html#_pitfalls_synchronization_challenges">14.5. Pitfalls: Synchronization challenges</a></li>
<li><a href="chap14.html#_solution_dining_philosophers">14.6. Solution: Dining philosophers</a></li>
<li><a href="chap14.html#_exercises_13">14.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap15.html">15. Constructing Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap15.html#_problem_math_tutor">15.1. Problem: Math tutor</a></li>
<li><a href="chap15.html#_concepts_graphical_user_interfaces">15.2. Concepts: Graphical user interfaces</a></li>
<li><a href="chap15.html#_syntax_guis_in_java">15.3. Syntax: GUIs in Java</a></li>
<li><a href="chap15.html#_solution_math_tutor">15.4. Solution: Math tutor</a></li>
<li><a href="chap15.html#_concurrency_guis">15.5. Concurrency: GUIs</a></li>
<li><a href="chap15.html#_summary_5">15.6. Summary</a></li>
<li><a href="chap15.html#_exercises_14">15.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap16.html">16. Testing and Debugging</a>
<ul class="sectlevel2">
<li><a href="chap16.html#_fixing_bugs">16.1. Fixing bugs</a></li>
<li><a href="chap16.html#_concepts_approaches_to_debugging">16.2. Concepts: Approaches to debugging</a></li>
<li><a href="chap16.html#_syntax_java_debugging_tools">16.3. Syntax: Java debugging tools</a></li>
<li><a href="chap16.html#_concurrency_parallel_bugs">16.4. Concurrency: Parallel bugs</a></li>
<li><a href="chap16.html#_finding_and_avoiding_bugs">16.5. Finding and avoiding bugs</a></li>
<li><a href="chap16.html#_concepts_design_implementation_and_testing">16.6. Concepts: Design, implementation, and testing</a></li>
<li><a href="chap16.html#_syntax_java_testing_tools">16.7. Syntax: Java testing tools</a></li>
<li><a href="chap16.html#_concurrency_testing_tools">16.8. Concurrency: Testing tools</a></li>
<li><a href="chap16.html#_examples_testing_a_class">16.9. Examples: Testing a class</a></li>
<li><a href="chap16.html#_exercises_15">16.10. Exercises</a></li>
</ul>
</li>
<li><a href="chap17.html">17. Polymorphism</a>
<ul class="sectlevel2">
<li><a href="chap17.html#_problem_banking_account_with_a_vengeance">17.1. Problem: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concepts_polymorphism">17.2. Concepts: Polymorphism</a></li>
<li><a href="chap17.html#_syntax_inheritance_tools_in_java">17.3. Syntax: Inheritance tools in Java</a></li>
<li><a href="chap17.html#_solution_banking_account_with_a_vengeance">17.4. Solution: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concurrency_atomic_libraries">17.5. Concurrency: Atomic libraries</a></li>
<li><a href="chap17.html#_exercises_16">17.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap18.html">18. Dynamic Data Structures</a>
<ul class="sectlevel2">
<li><a href="chap18.html#_problem_infix_conversion">18.1. Problem: Infix conversion</a></li>
<li><a href="chap18.html#_concepts_dynamic_data_structures">18.2. Concepts: Dynamic data structures</a></li>
<li><a href="chap18.html#_syntax_dynamic_arrays_and_linked_lists">18.3. Syntax: Dynamic arrays and linked lists</a></li>
<li><a href="chap18.html#_syntax_abstract_data_types_adt">18.4. Syntax: Abstract data types (ADT)</a></li>
<li><a href="chap18.html#_advanced_generic_data_structures">18.5. Advanced: Generic data structures</a></li>
<li><a href="chap18.html#_solution_infix_conversion">18.6. Solution: Infix conversion</a></li>
<li><a href="chap18.html#_concurrency_linked_lists_and_thread_safety">18.7. Concurrency: Linked lists and thread safety</a></li>
<li><a href="chap18.html#_concurrency_thread_safe_libraries">18.8. Concurrency: Thread-safe libraries</a></li>
<li><a href="chap18.html#_exercises_17">18.9. Exercises</a></li>
</ul>
</li>
<li><a href="chap19.html">19. Recursion</a>
<ul class="sectlevel2">
<li><a href="chap19.html#_problem_maze_of_doom">19.1. Problem: Maze of doom</a></li>
<li><a href="chap19.html#_concepts_recursive_problem_solving">19.2. Concepts: Recursive problem solving</a></li>
<li><a href="chap19.html#_syntax_recursive_methods">19.3. Syntax: Recursive methods</a></li>
<li><a href="chap19.html#_syntax_recursive_data_structures">19.4. Syntax: Recursive data structures</a></li>
<li><a href="chap19.html#_solution_maze_of_doom">19.5. Solution: Maze of doom</a></li>
<li><a href="chap19.html#_concurrency_futures">19.6. Concurrency: Futures</a></li>
<li><a href="chap19.html#_exercises_18">19.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap20.html">20. File I/O</a>
<ul class="sectlevel2">
<li><a href="chap20.html#_problem_a_picture_is_worth_1000_bytes">20.1. Problem: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concepts_file_io">20.2. Concepts: File I/O</a></li>
<li><a href="chap20.html#_syntax_file_operations_in_java">20.3. Syntax: File operations in Java</a></li>
<li><a href="chap20.html#_examples_file_examples">20.4. Examples: File examples</a></li>
<li><a href="chap20.html#fileChapterSolution">20.5. Solution: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concurrency_file_io">20.6. Concurrency: File I/O</a></li>
<li><a href="chap20.html#_exercises_19">20.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap21.html">21. Network Communication</a>
<ul class="sectlevel2">
<li><a href="chap21.html#_problem_web_server">21.1. Problem: Web server</a></li>
<li><a href="chap21.html#_concepts_tcpip_communication">21.2. Concepts: TCP/IP communication</a></li>
<li><a href="chap21.html#_syntax_networking_in_java">21.3. Syntax: Networking in Java</a></li>
<li><a href="chap21.html#_solution_web_server">21.4. Solution: Web server</a></li>
<li><a href="chap21.html#_concurrency_networking">21.5. Concurrency: Networking</a></li>
<li><a href="chap21.html#_exercises_20">21.6. Exercises</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">





















<div class="sect1">
<h2 id="ch13-concurrency">13. Programação Concorrente</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>O tempo é a substância da qual sou feito. O tempo é um rio que me arrasta, mas
eu sou o rio; é um tigre que me devora, mas eu sou o tigre; é um fogo que me
consome, mas eu sou o fogo.</p>
</div>
</blockquote>
<div class="attribution">
— Jorge Luis Borges
</div>
</div>
<div class="sect2">
<h3 id="_introdução">13.1. Introdução</h3>
<div class="paragraph">
<p>Até agora, nos concentramos principalmente em escrever programas sequenciais. A
execução sequencial significa que as instruções do programa são executadas uma
de cada vez em uma sequência determinada pela lógica do programa e pelos dados
de entrada. No entanto, mais de uma instrução de programa pode ser executada
independentemente por um processador multicore. Embora seja comum os programadores
escreverem programas sequenciais, a disponibilidade generalizada de processadores
de vários núcleos em um único computador levou a um aumento na demanda por
programadores que possam escrever programas concorrentes.</p>
</div>
<div class="paragraph">
<p>Um programa concorrente é aquele em que várias instruções podem ser executadas
simultaneamente por dois ou mais núcleos. Neste capítulo, mostramos como escrever
programas concorrentes simples em Java que exploram o poder de um computador com
vários núcleos. Começamos com um problema em que o destino do planeta está em
grave perigo!</p>
</div>
</div>
<div class="sect2">
<h3 id="_problema_vírus_mortal">13.2. Problema: Vírus mortal</h3>
<div class="paragraph">
<p>Um vírus mortal capaz de exterminar a população mundial está prestes a ser liberado
por um gênio do mal. Somente ele sabe o código de segurança que pode interromper a
contagem regressiva.  O mundo está condenado. A única esperança de salvação está em
você e em suas habilidades de programação em Java. Por meio das investigações de uma
rede de espionagem ultrassecreta e financiada pelo governo, foi revelado que o código
de segurança está vinculado ao número 59.984.005.171.248.659. Esse grande número é
o produto de dois números primos, e o código de segurança é a soma deles. Tudo o que
você precisa fazer é fatorar o número 59.984.005.171.248.659 em seus dois fatores
primos e somá-los.</p>
</div>
<div class="paragraph">
<p>É claro que há uma pegadinha.  O vírus mortal será lançado em breve, tão em breve que
talvez não haja tempo suficiente para seu computador pesquisar todos os números um a
um. Em vez disso, você deve usar a concorrência para verificar mais de um número por vez.</p>
</div>
<div class="paragraph">
<p>Esse problema parece artificial?  Para manter a privacidade das informações enviadas
pela Internet, muitos tipos de criptografia de chave pública dependem da dificuldade
de fatorar números grandes. Embora a fatoração do número nesse problema não seja
difícil, os números usados para criptografia de chave pública, geralmente com mais de
300 dígitos decimais, resistem à fatoração até mesmo pelos computadores mais rápidos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conceitos_dividindo_para_conquistar">13.3. Conceitos: Dividindo para conquistar</h3>
<div class="paragraph">
<p>O problema do vírus mortal tem uma grande tarefa (fatorar um número) a ser executada.
Como devemos dividir essa tarefa para que possamos realizá-la mais rapidamente? Dividir
o trabalho a ser feito é o cerne de qualquer solução simultânea para um problema.</p>
</div>
<div class="paragraph">
<p>Em um processador com vários núcleos, cada núcleo é um trabalhador independente. É
preciso algum cuidado para coordenar esses trabalhadores. Antes de tudo, ainda precisamos
obter a resposta correta. Uma solução concorrente não tem valor se estiver incorreta
e, ao ler e gravar na mesma memória compartilhada, as respostas encontradas por um
núcleo podem corromper as respostas encontradas por outros núcleos. A prevenção desse
problema será abordada no <a href="chap14.html">Chapter 14</a>. Quando pudermos
garantir que a solução concorrente está correta, também vamos querer melhorar o desempenho.
Talvez queiramos que a tarefa seja concluída mais rapidamente. Talvez tenhamos um sistema
interativo que deva continuar a lidar com as solicitações dos usuários mesmo que esteja
trabalhando em uma solução em segundo plano. Novamente, se a sobrecarga de coordenar nossos
trabalhadores levar mais tempo do que uma solução sequencial ou tornar o sistema menos
responsivo, isso não será útil.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#sharedThreadVariableExercise">[sharedThreadVariableExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Há duas maneiras principais de dividir o trabalho. A primeira é chamada de <em>decomposição
de tarefas</em>. Nessa abordagem, cada funcionário recebe uma tarefa diferente para fazer. A
segunda é chamada de <em>decomposição de domínio</em>. Nessa abordagem, os funcionários fazem o
mesmo trabalho, mas com dados diferentes.</p>
</div>
<div class="paragraph">
<p>É possível usar tanto a decomposição de tarefas quanto a de domínios para resolver o mesmo
problema. Com os dois tipos de decomposição, geralmente é necessário coordenar os
trabalhadores para que possam compartilhar informações. Nas próximas duas subseções,
descreveremos com mais detalhes a decomposição de tarefas e a decomposição de domínios.
Em seguida, discutiremos o mapeamento de tarefas para <em>threads</em> de execução e as diferentes
arquiteturas de memória que podem ser usadas para programação simultânea.</p>
</div>
<div class="sect3">
<h4 id="_decomposição_de_tarefas">13.3.1. Decomposição de tarefas</h4>
<div class="paragraph">
<p>A ideia de dividir uma tarefa em subtarefas menores é natural. Imagine que você está
planejando um jantar. Você precisa comprar suprimentos, preparar o jantar, limpar a casa
e arrumar a mesa. Se quatro de vocês estivessem planejando a festa, cada um poderia
realizar uma atividade separada. Os preparativos poderiam ser muito mais rápidos do que
se uma única pessoa estivesse fazendo o trabalho, mas a coordenação ainda é importante.
Talvez a pessoa que estiver preparando o jantar não possa terminar até que certos
suprimentos sejam comprados.</p>
</div>
<div class="paragraph">
<p>A decomposição de tarefas geralmente é mais fácil do que a decomposição de domínios porque
muitas tarefas têm divisões naturais. Infelizmente, essa nem sempre é uma maneira eficaz de
usar vários núcleos em um computador. Se uma tarefa for concluída muito antes das outras,
um núcleo poderá ficar ocioso.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#minimumTimeForTasksExercise">[minimumTimeForTasksExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Os dois exemplos a seguir mostram ilustrações simples do processo de divisão de uma tarefa em subtarefas menores no contexto da programação multicore.</p>
</div>
<div id="videoGameTasksExample" class="exampleblock">
<div class="title">Exemplo 13.1 Tarefas de videogame</div>
<div class="content">
<div class="paragraph">
<p>Considere um videogame simples que consiste nas seguintes tarefas</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Iniciar o jogo</p>
</li>
<li>
<p>Processar a jogada</p>
</li>
<li>
<p>Atualizar pontuação</p>
</li>
<li>
<p>Repintar a tela</p>
</li>
<li>
<p>Encerrar o jogo</p>
</li>
</ol>
</div>
<div id="figure-video_game_tasks" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/video-game-tasks.svg" alt="video game tasks" width="75%">
</div>
<div class="title">Figura 13.1 Execução de tarefas em um vídeogame. (a) Execução sequencial em um núcleo. (b) Execução concorrente em dois núcleos. As setas indicam o fluxo de execução e de transferência de dados.</div>
</div>
<div class="paragraph">
<p>Suponha que as tarefas B e D sejam independentes e possam ser executadas simultaneamente se houver dois núcleos disponíveis. A tarefa D atualiza continuamente a tela com os dados antigos até que a tarefa C atualize as informações.</p>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-video_game_tasks">Figura 13.1</a>(a) e (b) mostram como as tarefas desse videogame podem ser sequenciadas, respectivamente, em um único núcleo ou em dois núcleos. Todas as tarefas são executadas sequencialmente em um processador de núcleo único. Em um processador de núcleo duplo, as tarefas B e C podem ser executadas em um núcleo enquanto a tarefa D é executada simultaneamente em outro. Observe na figura que a tarefa C envia a pontuação e qualquer outros dados para a tarefa D, que atualiza continuamente a tela. Ter dois núcleos pode permitir uma atualização mais rápida da tela, pois o processador não precisa esperar que as tarefas B ou C sejam concluídas.</p>
</div>
</div>
</div>
<div id="mathExpressionTasksExample" class="exampleblock">
<div class="title">Exemplo 13.2 Tarefas de expressão matemática</div>
<div class="content">
<div class="paragraph">
<p>Suponha que precisemos avaliar a expressão matemática 2<em>Kate</em><sup>-⁠<em>at</em>²</sup> com os parâmetros <em>a</em> e <em>K</em> em um determinado valor de <em>t</em>. Podemos dividir a expressão em dois termos: 2<em>Kat</em> e <em>e</em><sup>-⁠<em>at</em>²</sup>. Cada um desses termos pode ser atribuído a uma tarefa diferente para avaliação. Em um processador de dois núcleos, essas duas tarefas podem ser executadas em núcleos separados e os resultados de cada uma delas podem ser combinados para encontrar o valor da expressão para a tarefa principal.</p>
</div>
<div id="figure-math_evaluation" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/mathematical-expression-evaluation.svg" alt="mathematical expression evaluation" width="75%">
</div>
<div class="title">Figura 13.2 Avaliação de uma expressão matemática (a) sequencialmente em um único núcleo e (b) simultaneamente em dois núcleos. As setas mostram o fluxo de execução e a transferência de dados. A fonte em destaque indica a operação que está sendo executada.</div>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-math_evaluation">Figura 13.2</a> mostra como essa expressão pode ser avaliada em processadores de um núcleo e de dois núcleos. Às vezes, o uso de vários núcleos para avaliar uma expressão como essa levará menos tempo do que um único núcleo. No entanto, não há garantia de que o uso de vários núcleos sempre será mais rápido, pois as tarefas levam tempo para serem configuradas e para se comunicarem entre si.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#mathExpressionTimingExercise">[mathExpressionTimingExercise]</a><br>
<a href="chap13.html#quad-coreExercise">[quad-coreExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Esses exemplos ilustram como uma tarefa pode ser dividida em duas ou mais subtarefas executadas por diferentes núcleos de um processador. Usamos um processador dual-core em nossos exemplos, mas as mesmas ideias podem ser expandidas para um número maior de núcleos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_decomposição_de_domínio">13.3.2. Decomposição de domínio</h4>
<div class="paragraph">
<p>Em um programa de computador, cada tarefa executa operações em dados. Esses dados são chamados de <em>domínio</em> dessa tarefa. Na decomposição do domínio, os dados são divididos em partes menores, em que cada parte é atribuída a um núcleo diferente, em vez de dividir uma tarefa em subtarefas. Assim, cada núcleo executa a mesma tarefa, mas em dados diferentes.</p>
</div>
<div class="paragraph">
<p>No exemplo do jantar, poderíamos ter usado a decomposição de domínio em vez de (ou além de) decomposição de tarefa. Se quiser cozinhar uma grande quantidade de purê de batatas, você mesmo pode descascar 24 batatas. Entretanto, se houver quatro pessoas (e cada uma delas tiver um descascador de batatas), cada pessoa precisará descascar apenas 6 batatas.</p>
</div>
<div class="paragraph">
<p>A estratégia de decomposição de domínio é muito útil e é um dos principais focos da simultaneidade neste livro. Os problemas da computação moderna geralmente usam dados maciços, que incluem milhões de valores ou milhares de registros de bancos de dados. Escrever programas que possam dividir os dados de modo que vários núcleos possam processar seções menores pode acelerar muito o tempo necessário para concluir o cálculo.</p>
</div>
<div class="paragraph">
<p>De certa forma, a decomposição de domínios pode ser mais difícil do que a decomposição de tarefas. Os dados devem ser divididos de maneira uniforme e justa. Depois que cada seção de dados tiver sido processada, os resultados deverão ser combinados. Empresas como o Google, que processam grandes quantidades de informações, desenvolveram uma terminologia para descrever esse processo. Dividir os dados e atribuí-los aos funcionários é chamado de etapa do mapa (<em>map</em>). A combinação das respostas parciais na resposta final é chamada de etapa de redução (<em>reduce</em>).</p>
</div>
<div class="paragraph">
<p>Ilustramos a estratégia de decomposição de domínio nos dois exemplos a seguir.</p>
</div>
<div id="arraySummationPreviewExample" class="exampleblock">
<div class="title">Exemplo 13.3 Visualização da soma de matrizes</div>
<div class="content">
<div class="paragraph">
<p>Suponha que queiramos aplicar a função <em>f</em> a cada elemento
de uma matriz <em>a</em> e somar os resultados. Matematicamente, queremos calcular a seguinte soma.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/oneCoreSum.svg" alt="oneCoreSum" width="15%">
</div>
</div>
<div class="paragraph">
<p>Nessa fórmula, <em>a</em><sub><em>i</em></sub> é o <em>i</em><sup>ésimo</sup> elemento da matriz <em>a</em>. Vamos supor que temos um processador dual-core disponível para calcular a soma. Dividimos a matriz de modo que cada núcleo execute a tarefa em metade da matriz. Sejam <em>S</em><sub>1</sub> e <em>S</em><sub>2</sub> denotem as somas calculadas pelo núcleo 1 e pelo núcleo 2, respectivamente.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/twoCoreSum.svg" alt="twoCoreSum" width="50%">
</div>
</div>
<div class="paragraph">
<p>Supondo que <em>N</em> seja uniforme, os dois núcleos processam exatamente a
mesma quantidade de dados. Para <em>N</em> ímpar, um dos núcleos processa
um item de dados a mais do que o outro.</p>
</div>
<div id="figure-array_decomposition" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/arrayDecomposition.svg" alt="arrayDecomposition" width="60%">
</div>
<div class="title">Figura 13.3 Calculando a soma de uma função de cada elemento de uma matriz.</div>
</div>
<div class="paragraph">
<p>Depois que <em>S</em><sub>1</sub> e <em>S</em><sub>2</sub> tiverem sido computados, um dos
núcleos pode somar esses dois números para obter <em>S</em>.
Essa estratégia é ilustrada em <a href="chap13.html#figure-array_decomposition">Figura 13.3</a>.
Depois que os dois núcleos tiverem concluído seu trabalho em cada metade da matriz,
as somas individuais são então somadas para produzir o resultado final.</p>
</div>
</div>
</div>
<div id="matrixMultiplicationPreviewExample" class="exampleblock">
<div class="title">Exemplo 13.4 Visualização da multiplicação de matrizes</div>
<div class="content">
<div class="paragraph">
<p>A necessidade de multiplicar matrizes surge em muitas aplicações matemáticas, científicas e de engenharia. Suponha que nos peçam para escrever um programa para
multiplicar duas matrizes quadradas <em>A</em> e <em>B</em>, que
são ambas matrizes <em>n</em> × <em>n</em>. A matriz do produto
<em>C</em> também será <em>n</em> × <em>n</em>. Um programa
sequencial calculará cada elemento da matriz <em>C</em> um de cada vez.
vez. Entretanto, um programa simultâneo pode calcular mais de um elemento de
<em>C</em> simultaneamente usando vários núcleos.</p>
</div>
<div id="figure-matrix_decomposition" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/matrixDecomposition.svg" alt="matrixDecomposition" width="75%">
</div>
<div class="title">Figura 13.4 Decomposição de dados para multiplicar duas matrizes 4 × 4. Os dois núcleos executam as mesmas tarefas de multiplicação, mas em dados diferentes da matriz <em>A</em>.Os dois núcleos calculam as duas linhas superiores e as duas linhas inferiores de <em>C</em>, respectivamente.</div>
</div>
<div class="paragraph">
<p>Neste problema, a tarefa é multiplicar as matrizes <em>A</em> e
<em>B</em>. Por meio da decomposição de domínio, podemos replicar essa
tarefa em cada núcleo. Conforme mostrado na <a href="chap13.html#figure-matrix_decomposition">Figura 13.4</a>,
cada núcleo calcula apenas uma parte de <em>C</em>. Por exemplo, se
<em>A</em> e <em>B</em> forem 4 × 4, podemos pedir a um núcleo que calcule o produto das duas primeiras
linhas de <em>A</em> com todas as quatro colunas de <em>B</em> para
gerar as duas primeiras linhas de <em>C</em>. O segundo núcleo calcula
as duas linhas restantes de <em>C</em>. Ambos os núcleos podem acessar as
matrizes <em>A</em> e <em>B</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tarefas_e_threads">13.3.3. Tarefas e threads</h4>
<div class="paragraph">
<p>É responsabilidade do programador dividir sua solução em
uma série de tarefas e subtarefas que serão executadas em um ou mais núcleos de um
processador. Nas seções anteriores, descrevemos programas concorrentes como se
tarefas específicas pudessem ser atribuídas a núcleos específicos, mas o Java não
fornece uma maneira direta de fazer isso.</p>
</div>
<div class="paragraph">
<p>Em vez disso, um programador Java deve agrupar um conjunto de tarefas e
subtarefas em uma <em>thread</em>. Uma thread é muito parecido com um programa
sequencial. De fato, todos os programas sequenciais são compostos de uma única thread.
Uma thread é um segmento de execução de código que percorre suas instruções passo a passo. Cada thread pode ser executado de forma independente. Se você tiver um processador de núcleo único
apenas uma thread pode ser executada por vez, e todas as threads se revezarão. Se você tiver um processador com vários núcleos, tantas threads quantos forem os núcleos
núcleos podem ser executados ao mesmo tempo. Não é possível escolher em qual núcleo uma
determinada thread será executada. Na maioria dos casos, você não conseguirá nem mesmo
saber qual núcleo uma determinada thread está usando.</p>
</div>
<div class="paragraph">
<p>Ele tem o cuidado de empacotar o conjunto certo de tarefas em uma única thread
de execução. Lembre-se dos exemplos anteriores de programação concorrente neste capítulo.</p>
</div>
<div class="paragraph">
<p>Considere a possibilidade de dividir as tarefas em <a href="chap13.html#videoGameTasksExample">Exemplo 13.1</a> em
duas threads. As tarefas B e C podem ser agrupadas na thread 1, e a tarefa D
pode ser empacotada na thread 2.Essa divisão é mostrada em
<a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>(a).</p>
</div>
<div class="paragraph">
<p>As tarefas para avaliar diferentes subexpressões em <a href="chap13.html#mathExpressionTasksExample">Exemplo 13.2</a> também podem ser divididas em duas threads, conforme mostrado em <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a> (b). Em muitos problemas, há várias maneiras razoáveis de dividir um conjunto de subtarefas em threads.</p>
</div>
<div id="figure-tasks_in_threads" class="imageblock">
<div class="content">
<img src="chapters/13-concurrency/images/task-thread-packaging.svg" alt="task thread packaging" width="100%">
</div>
<div class="title">Figura 13.5 (a)&nbsp;Tarefas em um videogame mostradas agrupadas em duas threads. (b) Tarefas para avaliar uma expressão matemática mostrada empacotada em duas threads. Cada thread pode ou não ser executado no mesmo núcleo que o outro.</div>
</div>
<div class="paragraph">
<p>Observe que essas figuras são exatamente iguais às figuras anteriores, exceto
que as tarefas são agrupadas como threads em vez de núcleos. Esse agrupamento
corresponde melhor à realidade, pois podemos controlar como as tarefas são agrupadas
em threads, mas não como elas são atribuídas aos núcleos.</p>
</div>
<div class="paragraph">
<p>Em ambos os exemplos, temos duas threads. É possível que alguma outra thread tenha iniciado a execução dessas threads. Todo programa Java, simultâneo ou
sequencial, começa com uma thread. Vamos nos referir a essa thread como a thread
<em>main</em>, pois ela contém o método <code>main()</code>.</p>
</div>
<div class="paragraph">
<p><a href="chap13.html#arraySummationPreviewExample">Exemplo 13.3</a> e <a href="chap13.html#matrixMultiplicationPreviewExample">Exemplo 13.4</a> usam várias tarefas idênticas,
mas essas tarefas operam em dados diferentes. Em <a href="chap13.html#arraySummationPreviewExample">Exemplo 13.3</a>,
as duas tarefas podem ser atribuídas a duas threads que
operam em diferentes partes da matriz de entrada. A tarefa de somar
os resultados das duas threads pode ser uma thread separada ou uma
subtarefa incluída em uma das outras threads. Em
<a href="chap13.html#matrixMultiplicationPreviewExample">Exemplo 13.4</a>, as duas tarefas podem
novamente ser atribuídas a duas threads distintas que operam em diferentes
partes diferentes da matriz de entrada <em>A</em> para gerar as partes correspondentes
partes correspondentes da matriz de saída <em>C</em>.</p>
</div>
<div class="paragraph">
<p>Pode haver muitas maneiras de empacotar tarefas em threads. Também pode haver
muitas maneiras de decompor os dados em pedaços menores. As melhores maneiras de
executar essas subdivisões de tarefas ou dados dependem do problema em questão e
da arquitetura do processador em que o programa será executado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arquitecturas_de_memória_e_concorrência">13.3.4. Arquitecturas de memória e concorrência</h4>
<div class="paragraph">
<p>Os dois paradigmas mais importantes da programação concorrente são a passagem de mensagens e os sistemas de memória compartilhada. Cada paradigma lida com a comunicação entre as várias unidades de código executadas em paralelo de uma maneira diferente. Os sistemas de passagem de mensagens, como o MPI (Message Passing Interface), abordam esse problema enviando mensagens entre unidades de código independentes, chamadas de processos. Um processo que está executando uma tarefa pode ter de esperar até receber uma mensagem de outro processo para saber como proceder. As mensagens podem ser enviadas de um único processo para outro ou transmitidas para vários. Os sistemas de passagem de mensagens são especialmente úteis quando os processadores que executam o trabalho não compartilham memória.</p>
</div>
<div class="paragraph">
<p>Por outro lado, o sistema interno de concorrência em Java usa o paradigma de memória compartilhada.
compartilhada. Em Java, um programador
pode criar várias threads que compartilham o mesmo espaço de memória. Cada
thread é um objeto que pode executar um trabalho. Descrevemos as threads como uma como uma forma de empacotar um grupo de tarefas, e os processos são outra forma. As pessoas
usam o termo <em>processos</em> para descrever unidades de código em execução com
memória separada e <em>threads</em> para descrever unidades de código em execução
com memória compartilhada.</p>
</div>
<div class="paragraph">
<p>Quando você aprendeu a programar pela primeira vez, um dos maiores desafios foi provavelmente aprender a resolver um problema passo a passo. Cada linha do programa tinha de ser executada uma de cada vez, de forma lógica e
deterministica. Os seres humanos não pensam naturalmente dessa forma. Temos a tendência de pular de uma coisa para outra, fazendo inferências e suposições,
pensando em duas coisas não relacionadas ao mesmo tempo, e assim por diante. Como você sabe
agora, só é possível escrever e depurar programas por causa da maneira metódica como eles funcionam.</p>
</div>
<div class="paragraph">
<p>Você pode imaginar a execução de um programa como uma seta que aponta para uma linha de código, depois a próxima, depois a próxima e assim por diante. Podemos pensar no movimento dessa seta como a thread de execução do programa.
O código faz o trabalho real, mas a seta mantém o controle de onde a
execução do programa está no momento. O código pode mover a seta
para frente, pode fazer aritmética básica, pode decidir entre escolhas com instruções pode fazer coisas repetidamente com loops, pode pular para um método e depois voltar. Uma única thread de execução pode fazer todas essas coisas, mas sua seta não pode estar em dois lugares ao mesmo tempo. Ela não pode
dividir dois números em uma parte do programa e avaliar uma declaração <code>if</code> em outra. No entanto, há uma maneira de dividir essa thread
de execução de modo que duas ou mais threads estejam executando partes diferentes
do programa, e a próxima seção mostrará como isso é feito em
Java.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sintaxe_threads_em_java">13.4. Sintaxe: Threads em Java</h3>
<div class="sect3">
<h4 id="_a_classe_thread">13.4.1. A classe <code>Thread</code></h4>
<div class="paragraph">
<p>O Java, como muitas linguagens de programação, inclui os recursos necessários para para empacotar tarefas e subtarefas em threads. A classe <code>Thread</code> e suas subclasses fornecem as ferramentas para criar e gerenciar threads. Por exemplo, a definição de classe a seguir permite que objetos do tipo
<code>ThreadedTask</code> sejam criados. Esse objeto pode ser executado como uma thread separada.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadedTask</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="c1">// Adicionar construtor e corpo da classe</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O construtor é escrito como qualquer outro construtor, mas há um método especial
<code>run()</code> em <code>Thread</code> que pode ser substituído por qualquer uma das
suas subclasses. Esse método é o ponto de partida para a thread de execução associada a uma instância da classe. A maioria dos aplicativos Java
começa com uma única thread principal que é iniciado em um método <code>main()</code>. As threads adicionais devem começar em algum lugar, e esse lugar é o método
 <code>run()</code>. Um aplicativo Java continuará a ser executado enquanto houver pelo menos uma thread ativa. O exemplo a seguir mostra duas threads,
cada uma avaliando uma subexpressão separada, como em <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>(b).</p>
</div>
<div id="threadSamplesExample" class="exampleblock">
<div class="title">Exemplo 13.5 Exemplos de Threads</div>
<div class="content">
<div class="paragraph">
<p>Vamos criar as classes <code>Thread1</code> e <code>Thread2</code>. As threads de execução criadas por
instâncias destas classes calculam, respetivamente, as duas subexpressões da
<a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>(b) e guardam os valores calculados.</p>
</div>
<div id="Thread1Program" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread1</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="no">K</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
 
    <span class="kd">public</span> <span class="nf">Thread1</span><span class="o">(</span><span class="kt">double</span> <span class="no">K</span><span class="o">,</span> <span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">K</span> <span class="o">=</span> <span class="no">K</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="no">K</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div id="Thread2Program" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread2</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
    
    <span class="kd">public</span>  <span class="nf">Thread2</span><span class="o">(</span><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">exp</span><span class="o">(-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O método <code>run()</code> em cada thread acima calcula uma subexpressão e salva seu
valor. Mostramos como essas threads podem ser executados para resolver o problema
da expressão matemática em <a href="chap13.html#mathExpressionThreadsExample">Exemplo 13.6</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_criando_um_objeto_thread">13.4.2. Criando um objeto thread</h4>
<div class="paragraph">
<p>Criar um objeto a partir de uma subclasse <code>Thread</code> é o mesmo que criar
qualquer outro objeto em Java. Por exemplo, podemos instanciar a classe <code>Thread1</code>
acima para criar um objeto chamado <code>thread1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Thread1</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread1</span><span class="o">(</span><span class="mf">15.1</span><span class="o">,</span> <span class="mf">2.8</span><span class="o">,</span> <span class="mf">7.53</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O uso da palavra-chave <code>new</code> para invocar o construtor cria um objeto <code>Thread1</code>,
mas não começa a executá-lo como uma nova thread. Como em todas as
outras classes, o construtor inicializa os valores dentro do novo objeto
objeto. Uma subclasse de <code>Thread</code> pode ter muitos construtores diferentes com
qualquer parâmetros que seu projetista considere apropriados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_iniciando_uma_thread">13.4.3. Iniciando uma thread</h4>
<div class="paragraph">
<p>Para iniciar a execução do objeto thread, seu método <code>start()</code> deve ser
chamado. Por exemplo, o objeto <code>thread1</code> criado acima pode ser iniciado
da seguinte forma.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez iniciado, uma thread é executada de forma independente.  A chamada do método <code>start()</code>
chama automaticamente o método <code>run()</code> do objeto nos bastidores.
Quando uma thread precisa compartilhar dados com outra thread, ela
pode ter que esperar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aguardando_por_uma_thread">13.4.4. Aguardando por uma thread</h4>
<div class="paragraph">
<p>Muitas vezes, alguma thread, principal ou não, precisa esperar por outra thread
antes de prosseguir com sua execução. O método <code>join()</code> é usado para esperar
que uma thread termine a execução. Por exemplo, qualquer thread que executar o
código a seguir aguardará a conclusão da <code>thread1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A chamada <code>join()</code> é uma chamada <em>bloqueante</em>, o que significa que o código que chama
esse método aguardará até que ele retorne. Como ele pode lançar uma
<code>InterruptedException</code> verificada enquanto o código estiver aguardando, o método <code>join()</code>
é geralmente usado em um bloco <code>try</code>-<code>catch</code>. Podemos adicionar um bloco <code>try</code>-<code>catch</code>
ao exemplo <code>thread1</code> para que possamos nos recuperar de
sermos interrompidos enquanto aguardamos a conclusão do <code>thread1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="k">try</span> <span class="o">{</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Aguardando pela thread 1..."</span><span class="o">);</span>
	<span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 finalizada!"</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 não acabou!"</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe que a <code>InterruptedException</code> é lançada porque a thread principal
foi interrompida enquanto aguardava a conclusão da <code>thread1</code>. Se a chamada <code>join()</code>
retornar, então <code>thread1</code> deve ter terminado e informaremos o usuário.
Se uma <code>InterruptedException</code> for lançada, alguma thread externa deve ter
interrompido a thread principal, forçando-a a parar de esperar pela <code>thread1</code>.</p>
</div>
<div class="paragraph">
<p>In earlier versions of Java, there was a <code>stop()</code> method which would
stop an executing thread. Although this method still exists, it’s been
deprecated and shouldn’t be used because it can make a program behave
in an unexpected way.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#threadMethodsExercise">[threadMethodsExercise]</a></p>
</div>
</div>
</div>
<div id="mathExpressionThreadsExample" class="exampleblock">
<div class="title">Exemplo 13.6 Cálculos matemáticos com threads</div>
<div class="content">
<div class="paragraph">
<p>Agora que temos a sintaxe para iniciar threads e esperar que eles terminem, podemos
usar as threads definidos em <a href="chap13.html#threadSamplesExample">Exemplo 13.5</a> com uma thread principal
para criar nosso primeiro programa concorrente completo.  A thread principal na
classe <code>MathExpression</code> cria e inicia as threads de trabalho <code>thread1</code> e <code>thread2</code>
e aguarda sua conclusão. Quando as duas threads concluem sua execução, podemos
solicitar a cada uma delas o valor calculado. A thread principal imprime o
produto desses valores, que é o resultado da expressão que queremos avaliar.</p>
</div>
<div id="MathExpressionProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MathExpression</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">120</span><span class="o">,</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">Thread1</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread1</span><span class="o">(</span><span class="no">K</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
        <span class="nc">Thread2</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// Start thread1</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// Start thread2</span>
        <span class="k">try</span> <span class="o">{</span> <span class="c1">// Wait for both threads to complete</span>
            <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value of expression: "</span> <span class="o">+</span>
                    <span class="n">thread1</span><span class="o">.</span><span class="na">getValue</span><span class="o">()*</span><span class="n">thread2</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A thread didn't finish!"</span><span class="o">);</span>
        <span class="o">}</span>        
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Queremos deixar absolutamente claro quando os threads são criados, começam
a execução e terminam. Esses detalhes são cruciais para os pontos mais finos da
programação Java simultânea. Na <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>, parece que a execução da avaliação da expressão matemática
começa com a Thread 1, que gera a Thread 2. Embora essa figura
explique bem os conceitos básicos da decomposição de tarefas, os detalhes são mais confusos para o código Java real.</p>
</div>
<div class="paragraph">
<p>No código acima, a execução começa com o método <code>main()</code> em
<code>MathExpression</code>. Ele cria os objetos <code>Thread1</code> e <code>Thread2</code> e aguarda
que eles terminem. Em seguida, ele lê os valores dos objetos depois que
eles pararam de ser executados. Poderíamos ter colocado o método <code>main()</code> na classe <code>Thread1</code>, omitindo totalmente a classe <code>MathExpression</code>. Desta forma isso faria com que a execução correspondesse mais de perto à <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>
mais próxima, mas tornaria as duas subclasses <code>Thread</code> menos
simétricas: a thread principal e a <code>thread1</code> executariam independentemente o código dentro da <code>Thread1</code>.
executariam independentemente o código dentro da classe <code>Thread1</code>, enquanto somente <code>thread2</code> executaria
executaria código dentro da classe <code>Thread2</code>.</p>
</div>
<div id="figure-thread_execution" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/thread-lifecycle.svg" alt="thread lifecycle" width="75%">
</div>
<div class="title">Figura 13.6 Criando, iniciando, e mesclando as threads em <code>MathExpression</code>, <code>Thread1</code>, and <code>Thread2</code>.</div>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-thread_execution">Figura 13.6</a> mostra a execução de <code>thread1</code> e
<code>thread2</code> e a thread principal. Observe que a JVM cria e inicia implicitamente
o thread principal, que cria e inicia explicitamente a <code>thread1</code> e a <code>thread2</code>.
Mesmo depois que as threads associados a <code>thread1</code> e <code>thread2</code> pararem de ser executados,
os objetos associados a eles continuam a existir. Seus métodos e campos ainda podem ser acessados.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_interface_runnable">13.4.5. A interface <code>Runnable</code></h4>
<div class="paragraph">
<p>Embora seja possível criar threads em Java herdando diretamente da classe
<code>Thread</code> diretamente, a API Java permite que o programador use uma
interface em vez disso.</p>
</div>
<div class="paragraph">
<p>Como exemplo, a classe <code>Summer</code> pega uma matriz de valores <code>int</code> e os soma dentro
de um determinado intervalo. Se várias instâncias dessa classe
forem executadas como threads separadas, cada uma delas poderá somar diferentes partes de
uma matriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Summer</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Summer</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sum</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa classe é muito semelhante a uma classe que herda de <code>Thread</code>. Imagine
por um momento que o código que segue <code>Summer</code> é <code>extends Thread</code>
em vez de <code>implements Runnable</code>. A principal coisa que uma classe derivada de
<code>Thread</code> precisa é de um método <code>run()</code> sobrescrito. Como somente o método <code>run()</code>
é importante, os projetistas do Java forneceram uma maneira de criar uma
thread usando a interface <code>Runnable</code>. Para implementar essa interface, é necessário apenas
um método <code>public void run()</code>.</p>
</div>
<div class="paragraph">
<p>Ao criar uma nova thread, há algumas diferenças de sintaxe entre os dois estilos. A maneira conhecida de criar e executar um thread a partir de uma subclasse <code>Thread</code> é a seguinte.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Summer</span> <span class="n">summer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Summer</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
<span class="n">summer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Como o <code>Summer</code> não herda de <code>Thread</code>, ele não tem um método <code>start()</code>, e esse código não será compilado. Quando uma classe apenas implementa <code>Runnable</code>, ainda é necessário criar um objeto <code>Thread</code> e chamar seu método <code>start()</code>. Portanto, é necessária uma etapa extra.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Summer</span> <span class="n">summer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Summer</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">summer</span><span class="o">);</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa forma alternativa de implementar a interface <code>Runnable</code> parece mais incômoda do que herdar diretamente da <code>Thread</code>, já que é necessário
instanciar um objeto <code>Thread</code> separado. Entretanto, a maioria dos desenvolvedores prefere projetar classes que implementem <code>Runnable</code> em vez de herdar de
<code>Thread</code>. Por quê? O Java só permite herança única. Se sua classe
implementar <code>Runnable</code>, ela estará livre para herdar de outra super classe
com os recursos que você desejar.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#extendingThreadExercise">[extendingThreadExercise]</a></p>
</div>
</div>
</div>
<div id="arrayOfThreadsExample" class="exampleblock">
<div class="title">Exemplo 13.7 Conjunto de threads</div>
<div class="content">
<div class="paragraph">
<p>Na decomposição de domínios, muitas vezes precisamos criar várias threads, todas
a partir da mesma classe. Como exemplo, considere a seguinte declaração de thread.</p>
</div>
<div id="NumberedThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberedThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">NumberedThread</span><span class="o">(</span><span class="kt">int</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">input</span><span class="o">;</span> <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, suponha que desejemos criar 10 objetos de thread do tipo
<code>NumberedThread</code>, então iniciá-los e por fim esperar que sejam concluídos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">NumberedThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberedThread</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberedThread</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="o">}</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="o">}</span>
<span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A thread didn't finish!"</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primeiro, declaramos uma matriz para manter referências aos objetos <code>NumberedThread</code>. Como qualquer outro tipo, podemos criar uma matriz para armazenar objetos que
herdam de <code>Thread</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A primeira linha do loop <code>for</code> instancia um novo objeto <code>NumberedThread</code>, invocando o construtor que armazena a
iteração atual do loop no campo <code>value</code>. A referência a
cada objeto <code>NumberedThread</code> é armazenada na matriz. Lembre-se de que o construtor
 <strong>não</strong> inicia a execução de uma nova thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A segunda linha do loop <code>for</code> faz isso.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Também estamos interessados em saber quando as threads param. A chamada do método <code>join()</code>
força a thread principal a aguardar a conclusão de cada thread.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Todo o segundo loop <code>for</code> está aninhado dentro de um bloco <code>try</code>. Se a thread principal for interrompida enquanto estiver aguardando a conclusão de qualquer uma das threads terminar, uma <code>InterruptedException</code> será capturada. Como antes, avisamos o usuário
que uma thread não foi concluída. Para código com qualidade de produção, o bloco
bloco <code>catch</code> deve tratar a exceção de forma que a thread possa se recuperar e fazer um trabalho útil, mesmo que não tenha obtido o resultado esperado.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exemplos_concorrência_e_aceleração">13.5. Exemplos: Concorrência e aceleração</h3>
<div class="paragraph">
<p>A aceleração é uma das maiores motivações para escrever programas
concorrentes. Para entender o aumento de velocidade, vamos supor que temos um problema para
resolver. Escrevemos dois programas para resolver esse problema, um que é
sequencial e outro que é concorrente e, portanto, capaz de explorar
vários núcleos. Seja <em>t</em><sub><em>s</em></sub> o tempo médio de execução do
o programa sequencial e <em>t</em><sub><em>c</em></sub> o tempo médio de execução do programa concorrente. Para que a comparação seja
significativa, suponha que ambos os programas sejam executados no mesmo computador.
O aumento de velocidade obtido com a programação concorrente é definido como <em>t</em><sub><em>s</em></sub>/<em>t</em><sub><em>c</em></sub>.</p>
</div>
<div class="paragraph">
<p>A aceleração mede quanto tempo leva para o programa concorrente ser executado em relação ao programa sequencial. Idealmente, esperamos que
<em>t</em><sub><em>c</em></sub> &lt; <em>t</em><sub><em>s</em></sub>, tornando a aceleração maior que 1. No entanto,
simplesmente escrever um programa concorrente não garante que ele seja mais rápido
do que a versão sequencial.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#speedupExercise">[speedupExercise]</a><br>
<a href="chap13.html#AmdahlLawExercise">[AmdahlLawExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Para determinar o aumento de velocidade, precisamos medir <em>t</em><sub><em>s</em></sub> e <em>t</em><sub><em>c</em></sub>. O
tempo em um programa Java pode ser facilmente medido com
os dois métodos estáticos a seguir na classe <code>System</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">currentTimeMillis</span><span class="o">()</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">nanoTime</span><span class="o">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro desses métodos retorna a hora atual em milissegundos (ms).
Um <em>millisecond</em> equivale a 0,001 segundos. Esse método fornece a diferença
entre a hora atual no relógio de seu computador e a meia-noite de
1º de janeiro de 1970, horário universal coordenado (UTC). Esse ponto no tempo é
usado para muitos recursos de tempo em muitas plataformas de computador e é chamado de <em>epoch Unix</em>. O outro método retorna a hora atual em
nanossegundos (ns). Um <em>nanossegundo</em> equivale a 0,000000001 ou 10<sup>-9</sup> segundos.
Esse método também fornece a diferença entre a hora atual e uma hora fixa, que depende do sistema e não necessariamente do <em>epoch</em>.
O método <code>System.nanoTime()</code> pode ser usado quando você quiser uma precisão de tempo
mais fina do que milissegundos; entretanto, o nível de precisão que ele retorna é
novamente dependente do sistema. O próximo exemplo mostra como usar esses métodos
para medir o tempo de execução.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 13.8 Medindo o tempo de execução</div>
<div class="content">
<div class="paragraph">
<p>Suponha que desejemos medir o tempo de execução de um trecho de código Java. Por conveniência, podemos supor que esse código esteja contido no método <code>work()</code>. O trecho de código a seguir mede o tempo de execução de
<code>work()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="n">work</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tempo decorrido: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída fornecerá o tempo de execução de <code>work()</code> medido em
milissegundos. Para obter o tempo de execução em nanossegundos, use o método
<code>System.nanoTime()</code> em vez de <code>System.currentTimeMillis()</code>.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#executionVariationExercise">[executionVariationExercise]</a><br>
<a href="chap13.html#threadOverheadExercise">[threadOverheadExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Agora que temos as ferramentas para medir o tempo de execução, podemos medir o
aumento de velocidade. Os próximos exemplos mostram o aumento de velocidade (ou a falta dele) que podemos
podemos obter usando uma solução simultânea para alguns problemas simples.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 13.9 Acelerando o cálculo matemático</div>
<div class="content">
<div class="paragraph">
<p>Lembre-se do programa concorrente em <a href="chap13.html#mathExpressionThreadsExample">Exemplo 13.6</a> para avaliar uma expressão matemática simples. Esse programa
usa duas threads. Executamos esse programa multithread em um computador iMac
com um Intel Core 2 Duo rodando a 2,16 Ghz. O tempo de execução
O tempo de execução foi medido em 1.660.000 nanossegundos. Também escrevemos um programa
programa sequencial simples para avaliar a mesma expressão. Foram necessários 4.100
nanossegundos para executar esse programa no mesmo computador. Ao inserir
esses valores para <em>t</em><sub><em>c</em></sub> e <em>t</em><sub><em>s</em></sub>, podemos encontrar
a aceleração.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/speedup.svg" alt="speedup" width="45%">
</div>
</div>
<div class="paragraph">
<p>Essa aceleração é muito menor que 1. Embora esse resultado possa ser surpreendente,
o programa concorrente com duas threads é executado mais lentamente do que o programa
sequencial. Nesse exemplo, o custo de criar, executar e
processar as threads supera os benefícios do cálculo simultâneo em dois
núcleos.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#speedupLimitationsExercise">[speedupLimitationsExercise]</a></p>
</div>
</div>
</div>
<div id="arraySummationExample" class="exampleblock">
<div class="title">Exemplo 13.10 Somatório de matrizes</div>
<div class="content">
<div class="paragraph">
<p>Em <a href="chap13.html#arraySummationPreviewExample">Exemplo 13.3</a>, apresentamos o
problema de aplicar uma função a cada valor em uma matriz e depois
somar os resultados. Digamos que queiramos aplicar a função seno
a cada valor. Para resolver esse problema de forma concorrente, particionamos
a matriz uniformemente entre várias threads, usando a estratégia de decomposição de domínio.
Cada thread encontra a soma dos senos dos valores em sua
parte da matriz. Um fator que determina se conseguimos ou não
velocidade é a complexidade da função, nesse caso o seno, que aplicamos.
aplicamos. Embora possamos obter um aumento de velocidade com o seno, uma função mais simples
como dobrar o valor pode não gerar trabalho suficiente para justificar a
sobrecarga do uso de threads.</p>
</div>
<div class="paragraph">
<p>Criamos a classe <code>SumThread</code> cujo método <code>run()</code> soma os senos dos
elementos da matriz em sua partição atribuída.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SumThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SIZE</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREADS</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">SumThread</span><span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
		<span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>     
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primeiro, configuramos todos os campos de que a classe precisará.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Observe que cada objeto <code>SumThread</code> terá sua própria referência à matriz de dados.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Fixamos o tamanho da matriz em 1.000.000 e o número de threads em 8, mas esses valores
podem ser facilmente alterados ou lidos como entrada.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Em seu construtor, um <code>SumThread</code> recebe uma referência à matriz de dados
e os limites inferior e superior de sua partição. Como a maioria dos
intervalos que discutimos, o limite inferior é inclusivo, embora o limite superior
seja exclusivo.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sin</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getSum</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sum</span><span class="o">;</span> <span class="o">}</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No loop <code>for</code> do método <code>run()</code>, a <code>SumThread</code> encontra o seno
de cada número em sua partição da matriz e adiciona esse valor à sua
soma.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>O método <code>getSum()</code> é um acessório que permite que a soma em execução seja
seja recuperada.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kt">double</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="no">SIZE</span><span class="o">];</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span>  
        <span class="nc">SumThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumThread</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="no">THREADS</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="no">THREADS</span><span class="o">;</span>          
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="n">quotient</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="o">)</span>
                <span class="n">work</span><span class="o">++;</span>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumThread</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">work</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">work</span><span class="o">;</span>
        <span class="o">}</span>   </code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>O método <code>main()</code> começa instanciando a matriz.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Ele o preenche com valores aleatórios.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Em seguida, cada thread é criado passando uma referência para o vetor e os limites
inferior e superior que marcam a partição da thread na matriz. Se o
processo que usa o comprimento da matriz e o número de threads para determinar
os limites superior e inferior não fizer sentido, consulte
<a href="chap6.html#_concurrency_arrays">Section 6.11</a> que descreve a divisão justa do trabalho
para as threads. Se o comprimento da matriz não for divisível pelo número de
threads, a divisão simples não será suficiente.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Depois que cada thread é criada, seu método <code>start()</code> é chamado.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">try</span> <span class="o">{</span> 
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getSum</span><span class="o">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum: "</span> <span class="o">+</span> <span class="n">threads</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getSum</span><span class="o">());</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="o">}</span>
    <span class="o">}</span>   
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Depois que as threads começam a trabalhar, a thread principal cria seu próprio
total em execução.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Ele itera através de cada thread esperando que seja concluído.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Quando cada thread é concluída, seu valor é adicionado ao
ao total em execução.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finalmente, a soma é impressa.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Se a thread principal for interrompida enquanto estiver aguardando a conclusão de uma
thread, o rastreamento da pilha será impresso.</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#parallelAudioProcessingExercise">[parallelAudioProcessingExercise]</a><br>
<a href="chap13.html#arraySummingSpeedupExercise">[arraySummingSpeedupExercise]</a><br>
<a href="chap13.html#treeSummationExercise">[treeSummationExercise]</a></p>
</div>
</div>
</div>
<div id="matrixMultiplicationExample" class="exampleblock">
<div class="title">Exemplo 13.11 Multiplicação de matrizes</div>
<div class="content">
<div class="paragraph">
<p>Em <a href="chap13.html#matrixMultiplicationPreviewExample">Exemplo 13.4</a>, discutimos a
a importância das operações de matriz em muitos aplicativos. Agora que conhecemos
a sintaxe Java necessária, podemos escrever um programa concorrente para multiplicar
duas matrizes quadradas <em>A</em> e <em>B</em> e calcular a matriz
resultante <em>C</em>. Se essas matrizes tiverem <em>n</em>
linhas e <em>n</em> colunas, o valor na <em>i</em><sup>ésima</sup>
linha e <em>j</em>^^ coluna de <em>C</em> é</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/matrixValue.svg" alt="matrixValue" width="55%">
</div>
</div>
<div class="paragraph">
<p>Em Java, é natural armazenarmos as matrizes como matrizes bidimensionais.
Para fazer essa multiplicação sequencialmente, a abordagem mais simples usa três
loops <code>for</code> aninhados. O código abaixo é uma tradução direta da
notação matemática, mas temos de ter cuidado com a contagem.
Observe que a notação matemática geralmente usa letras maiúsculas para
para representar matrizes, embora a convenção Java seja iniciar todos os nomes de variáveis
com letras minúsculas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
            <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A primeira etapa para criar uma solução concorrente para esse problema é
criar uma subclasse <code>Thread</code> que fará alguma parte da
multiplicação da matriz. Abaixo está a classe <code>MatrixThread</code> que calculará um
número de linhas na matriz de resposta <code>c</code>.</p>
</div>
<div id="MatrixThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MatrixThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">c</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>  
    
    <span class="kd">public</span> <span class="nf">MatrixThread</span><span class="o">(</span><span class="kt">double</span><span class="o">[][]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">b</span><span class="o">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>      
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>              
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>O construtor de <code>MatrixThread</code> armazena referências às matrizes
correspondentes às matrizes <em>A</em>, <em>B</em> e <em>C</em>, bem como os limites inferior e superior das linhas de
<em>C</em> a serem computadas.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>O corpo do método <code>run()</code> é idêntico ao da solução sequencial, exceto pelo fato de que seu <code>loop</code> mais externo é executado somente de
<code>lower</code> a <code>upper</code> em vez de percorrer todas as linhas do resultado.
É fundamental que a cada thread seja atribuído um conjunto de linhas que não se
se sobreponha às linhas que outra thread possui. Não só o fato de
várias threads calcularem a mesma linha seria ineficiente, mas muito provavelmente levaria
a um resultado incorreto, como veremos em
<a href="chap14.html">Chapter 14</a>.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>O código cliente a seguir usa uma matriz de objetos <code>MatrixThread</code> para
realizar uma multiplicação de matriz. Supomos que uma constante <code>int</code> denominada
<code>THREADS</code> tenha sido definida, o que dá o número de threads que queremos criar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">MatrixThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MatrixThread</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="no">THREADS</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="no">THREADS</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">quotient</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="o">)</span>
        <span class="n">rows</span><span class="o">++;</span>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MatrixThread</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">rows</span><span class="o">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">rows</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
<span class="o">}</span>
<span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Fazemos um <code>loop</code> pela matriz, criando um objeto <code>MatrixThread</code> para cada
posição. Como no exemplo anterior, usamos a abordagem descrita em
<a href="chap6.html#_concurrency_arrays">Section 6.11</a> para alocar linhas para cada thread de forma justa.
Cada novo objeto <code>MatrixThread</code> recebe uma referência a cada uma das três
matrizes, bem como uma linha inicial inclusiva e uma linha final exclusiva.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Depois que os objetos <code>MatrixThread</code> são criados, começamos a executá-los com a próxima linha de código.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Em seguida, há um <code>loop</code> <code>for</code> familiar com as chamadas <code>join()</code>
que forçam a thread principal a esperar que as outras threads terminem.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Presumivelmente,
o código após esse trecho imprimirá os valores da matriz de resultados
ou a usará para outros cálculos. Se não tivermos usado as chamadas <code>join()</code>
para garantir que as threads tenham terminado, poderíamos imprimir uma matriz de resultados que foi preenchida apenas parcialmente.</p>
</div>
<div class="paragraph">
<p>Concluímos o código da multiplicação de matrizes com threads e o executamos
em um computador iMac com um Intel Core 2 Duo rodando a 2,16 Ghz. O programa
foi executado para matrizes de diferentes tamanhos (<em>n</em> × <em>n</em>). Para cada tamanho, os
tempos de execução sequencial e concorrente em segundos
e o tempo de execucação correspondente estão listados na tabela a seguir.</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Size (<em>n</em>)</th>
<th class="tableblock halign-left valign-top"><em>t</em><sub><em>s</em></sub> (s)</th>
<th class="tableblock halign-left valign-top"><em>t</em><sub><em>c</em></sub> (s)</th>
<th class="tableblock halign-left valign-top">Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.013</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.75</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.39</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.45<sup>*</sup></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Somente com matrizes de 1.000 × 1.000 observamos um melhor
desempenho ao usar duas threads. Nesse caso, obtivemos um aumento de velocidade
de 1,45, marcado com um asterisco. Nos outros dois casos, o desempenho piorou.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#parallelPiApproximationExercise">[parallelPiApproximationExercise]</a><br>
<a href="chap13.html#matrixSpeedupExercise">[matrixSpeedupExercise]</a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conteitos_agendamento_de_thread">13.6. Conteitos: Agendamento de thread</h3>
<div class="paragraph">
<p>Agora que vimos como várias threads podem ser usadas juntas,
várias perguntas surgem: Quem decide quando
essas threads são executadas? Como o tempo do processador é compartilhado
entre as threads? Podemos fazer alguma suposição sobre a ordem de execução
das threads? Podemos afetar essa ordem?</p>
</div>
<div class="paragraph">
<p>Essas perguntas se concentram no agendamento de threads. Como diferentes sistemas
concorrente lidam com o agendamento de forma diferente, descreveremos apenas o agendamento
em Java. Embora a programação sequencial tenha tudo a ver com o controle preciso
sobre o que acontece <strong>depois</strong>, a concorrência tira grande parte desse controle do
programador. Quando os threads são agendados e em qual processador eles são executados, isso
é feito por uma combinação da JVM e do sistema operacional. Com as
JVMs normais, não há uma maneira explícita de acessar o agendamento e alterá-lo a seu
seu agrado.</p>
</div>
<div class="paragraph">
<p>Obviamente, há várias maneiras implícitas pelas quais um programador pode manipular a
a programação. Em Java, como em várias outras linguagens
e sistemas de programação, as threads têm <em>prioridades</em>. As threads de prioridade mais
alta são executadas com mais frequência do que as de prioridade mais baixa. Algumas
threads estão executando operações de missão crítica que devem ser executadas o mais
rápido possível, e algumas threads estão apenas realizando tarefas periódicas
em segundo plano. Um programador pode definir as prioridades das threads de acordo com essas prioridades.</p>
</div>
<div class="paragraph">
<p>A definição de prioridades oferece apenas uma maneira muito geral de controlar
qual thread será executada. As próprias threads podem ter informações mais específicas
sobre quando precisarão ou não de tempo de processador. A thread pode precisar esperar
por um evento específico e não precisará ser executada
até lá. O Java permite que as threads interajam com o agendador por meio dos
métodos <code>Thread.sleep()</code> e <code>Thread.yield()</code>, que discutiremos em <a href="#Syntax: Thread states" class="target-missing">[Syntax: Thread states]</a> e
por meio do método <code>wait()</code>, que discutiremos em <a href="chap14.html">Chapter 14</a>.</p>
</div>
<div class="sect3">
<h4 id="_não_determinismo">13.6.1. Não determinismo</h4>
<div class="paragraph">
<p>Em Java, o mapeamento de uma thread dentro da JVM para uma thread no sistema operacional
varia. Algumas implementações dão a cada thread Java uma thread do sistema operacional, outras
colocam todas as threads Java em uma única thread do sistema operacional (com o efeito
colateral de impedir a execução paralela), e algumas permitem a possibilidade de alterar
qual thread do sistema operacional uma thread Java usa. Assim, o desempenho e, em alguns
casos, a correção de seu programa podem variar, dependendo do sistema que você estiver executando.
Esse é, mais uma vez, um daqueles momentos em que o Java
é independente de plataforma…​ mas não totalmente.</p>
</div>
<div class="paragraph">
<p>Infelizmente, a situação é ainda mais complicada. Tornar as threads
parte de seu programa significa que o mesmo programa pode ser executado de forma diferente
no <strong>mesmo</strong> sistema. A JVM e o sistema operacional precisam cooperar para agendar as threads
e ambos os programas são montanhas complexas de código que tentam equilibrar muitos fatores.
Se você criar três threads, não há garantia
que o primeiro será executado primeiro, o segundo segundo e o terceiro terceiro,
mesmo que isso aconteça nas primeiras 10 vezes em que você executar o programa. O
<a href="chap13.html#executionOrderExercise">[executionOrderExercise]</a> mostra que o padrão de execução das threads pode variar muito.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#executionOrderExercise">[executionOrderExercise]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Em todos os programas anteriores a este capítulo, a mesma sequência de entrada
sempre produziria a mesma sequência de saída. Talvez o maior
obstáculo criado por esse não determinismo seja o fato de os programadores
terem de mudar seu paradigma consideravelmente. O processador pode alternar
entre execuções de de threads a qualquer momento, mesmo no meio das operações. Todas as possíveis
intercalações de execução de thread pode surgir em algum momento. A menos
que você tenha certeza de que seu programa se comporta adequadamente em todos
eles, talvez você nunca conseguirá depurar seu código completamente. O que é tão insidioso nos
bugs não determinísticos é que eles podem ocorrer raramente e ser quase
impossíveis de reproduzir. Neste capítulo, apresentamos como criar e executar
threads, mas fazer com que essas threads interajam adequadamente é um
problema importante que abordaremos nos capítulos seguintes.</p>
</div>
<div class="paragraph">
<p>Depois dessas terríveis palavras de advertência, gostaríamos de lembrá-lo de que
o não determinismo não é em si uma coisa ruim. Muitos aplicativos com threads
com muitas entradas e saídas, como os servidores de aplicação, necessariamente
existem em um mundo não determinístico. Para esses programas, muitas diferentes
sequências de threads em execução podem ser perfeitamente válidas. Cada programa
individual pode ter uma definição diferente de correção. Por exemplo, se um servidor
do mercado de ações receber duas solicitações para comprar a última ação de uma
determinada empresa quase ao mesmo tempo de duas threads correspondentes a dois
clientes diferentes, pode ser correto que qualquer um deles
obtenha a última ação. No entanto, nunca seria correto que <strong>ambos</strong> a recebam.</p>
</div>
</div>
<div class="sect3">
<h4 id="_votação">13.6.2. Votação</h4>
<div class="paragraph">
<p>Até agora, o único mecanismo que introduzimos para coordenar diferentes
threads é usar o método <code>join()</code> para aguardar o término de uma thread.
Outra técnica é <em>polling</em>, ou <em>busy waiting</em>. A ideia é continuar
verificando o estado de uma thread até que ela mude.</p>
</div>
<div class="paragraph">
<p>Há vários problemas com essa abordagem. O primeiro é que ela
desperdiça ciclos da CPU. Os ciclos gastos pela thread em espera continuamente
poderiam ter sido usados de forma produtiva por alguma outra thread no sistema. O
segundo problema é que precisamos ter certeza de que o estado da thread que
estamos esperando não voltará ao estado original ou para algum outro estado. Devido
à imprevisibilidade do agendamento,
não há garantia de que a thread em espera lerá o estado da outra thread quando
ela tiver o valor correto.</p>
</div>
<div class="paragraph">
<p>Mencionamos a votação em parte porque ela tem uma importância histórica para a
programação paralela, em parte porque pode ser útil na solução de alguns
problemas deste capítulo e, em parte, porque queremos que você entenda
os motivos pelos quais precisamos de técnicas melhores para a comunicação entre threads.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#pollingArraySumExercise">[pollingArraySumExercise]</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sintaxe_estados_da_thread">13.7. Sintaxe: Estados da thread</h3>
<div class="paragraph">
<p>Uma ferramenta Java amplamente utilizada para manipular o agendamento é o método <code>Thread.sleep()</code>. Esse método pode ser chamado sempre que você quiser que uma
thread não faça nada por um determinado período de tempo. Até que o temporizador <code>sleep</code>
expire, a thread não será agendada para nenhum tempo de CPU, a menos que seja
interrompida. Para fazer uma thread de execução dormir, chame <code>Thread.sleep()</code>
nessa thread de execução com um número de milissegundos como parâmetro. Por exemplo, chamar <code>Thread.sleep(2000)</code> fará com que a
thread chamada dormirá por dois segundos completos.</p>
</div>
<div class="paragraph">
<p>Outra ferramenta útil é o método <code>Thread.yield()</code>. Ele abre mão do uso da
CPU para que a próxima thread em espera possa ser executada. Para usá-lo, uma thread
chama <code>Thread.yield()</code>. Esse método é útil na prática, mas
de acordo com a documentação oficial, a JVM não <strong>tem</strong> que fazer nada quando
um <code>Thread.yield()</code> é executado. A especificação Java não exige uma implementação
específica. Uma JVM poderia ignorar uma chamada
chamada <code>Thread.yield()</code> completamente, mas a maioria das JVMs passará para a
próxima thread no cronograma.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#sleepAndYieldMethodsExercise">[sleepAndYieldMethodsExercise]</a><br>
<a href="chap13.html#sleepTimerExercise">[sleepTimerExercise]</a></p>
</div>
</div>
</div>
<div id="figure-thread_states" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/thread-states.svg" alt="thread states" width="80%">
</div>
<div class="title">Figura 13.7 Estados e transições da thread.</div>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-thread_states">Figura 13.7</a> mostra o ciclo de vida de uma thread. A
thread começa sua vida no estado <code>New Thread</code>, depois que o construtor
é chamado. Quando o método <code>start()</code> é chamado, a thread começa a ser executada
e faz a transição para o estado <code>Runnable. Ser executável não significa
necessariamente que a thread está sendo executada em um determinado momento, mas
que ela está pronta para ser executada a qualquer momento. Quando estiver no
estado `Runnable</code>, uma thread pode chamar <code>Thread.yield()</code>, deixando de usar o processador,
mas ainda permanecerá <code>Runnable</code>.</p>
</div>
<div class="paragraph">
<p>No entanto, se uma thread for dormir com uma chamada <code>Thread.sleep()</code>, aguardará
para que uma condição seja verdadeira usando uma chamada <code>wait()</code> ou executar uma operação de
de E/S bloqueante, a thread fará a transição para o estado <code>Not Runnable</code>. As
threads não executáveis não podem ser agendadas para o tempo de processador até que
acordem, terminem de esperar ou concluam sua E/S. O estado final é
<code>Terminated</code>. Uma thread se torna terminada quando seu método <code>run()</code>
termina. Uma thread terminada não pode se tornar executável novamente e
não é mais uma thread de execução separado.</p>
</div>
<div class="paragraph">
<p>Qualquer objeto com um tipo que seja uma subclasse de <code>Thread</code> pode informar seu
estado atual usando o método <code>getState()</code>. Esse método retorna um tipo <em>enum</em>, cujo
valor deve vir de uma lista fixa de objetos constantes. Esses objetos são <code>Thread.State.NEW</code>,
<code>Thread.State.RUNNABLE</code>, <code>Thread.State.BLOCKED</code>, <code>Thread.State.WAITING</code>,
<code>Thread.State.TIMED_WAITING</code> e <code>Thread.State.TERMINATED</code>. Embora os outros sejam
autoexplicativos, agrupamos o <code>Thread.State.BLOCKED</code>,
<code>Thread.State.WAITING</code> e <code>Thread.State.TIMED_WAITING</code> no estado <code>Not Runnable</code>, já que
a distinção entre os três não é importante para nós.</p>
</div>
<div class="paragraph">
<p>As threads também têm prioridades em Java. Quando um objeto que é uma subclasse
de <code>Thread</code> é criado em Java, sua prioridade é inicialmente a mesma da thread que o cria.
Normalmente, essa prioridade é <code>Thread.NORM_PRIORITY</code>, mas há alguns casos especiais em que é uma
boa ideia aumentar ou diminuir essa prioridade. Evite alterar as prioridades de thread
porque isso aumenta a dependência da plataforma e porque os efeitos nem sempre são previsíveis. Esteja
ciente de que as prioridades existem, mas não as use a menos que você tenha um bom motivo.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 13.12 Marcha militar</div>
<div class="content">
<div class="paragraph">
<p>Vamos aplicar as ideias discutidas acima a um exemplo leve. Você
talvez esteja familiarizado com o som de soldados marchando: “<code>Esquerda, esquerda, esquerda,
direita, esquerda!</code>” Podemos criar uma thread que imprima "Esquerda" e outra que imprima "Direita".
Podemos combinar as duas para imprimir a sequência correta
para marchar e repetir tudo 10 vezes para que possamos
ver com que precisão podemos posicionar as palavras. Queremos usar as ferramentas de agendamento
discutidas acima para obter o tempo correto. Vamos tentar <code>Thread.sleep()</code>
first.</p>
</div>
<div id="LeftThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeftThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>  <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <span class="o">}</span>  <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Left"</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dentro do loop <code>for</code>, essa thread imprime <code>Left</code> três vezes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Em seguida, ele aguarda 10 milissegundos.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finalmente, ele imprime <code>Esquerda</code> novamente e repete o loop.</td>
</tr>
</tbody></table>
</div>
<div id="RightThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RightThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">try</span> <span class="o">{</span>
			<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Right "</span><span class="o">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
				<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
			<span class="o">}</span>
		<span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Essa thread aguarda 5 milissegundos para ser sincronizada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Dentro de seu loop <code>for</code>, ele imprime <code>Right</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Em seguida, ela aguarda 10 milissegundos e repete o loop.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>O programa de driver abaixo cria uma thread para cada uma dessas
classes e, em seguida, as inicia. Se você executar esse programa, verá 10
linhas de <code>Left Left Left Right Left</code>, mas há alguns problemas.</p>
</div>
<div id="MilitaryMarchingProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MilitaryMarching</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">LeftThread</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LeftThread</span><span class="o">();</span>
        <span class="nc">RightThread</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RightThread</span><span class="o">();</span>
        <span class="n">left</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">right</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">right</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>       
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro problema é que temos que esperar algum tempo entre as
chamadas. Poderíamos encurtar as chamadas <code>Thread.sleep()</code>, mas há limites
na resolução do cronômetro. O maior problema é que as duas
threads podem, às vezes, ficar fora de sincronia. Se você executar o programa muitas
vezes, você poderá ver um <code>Right</code> fora do lugar de vez em quando. Se você
aumentar as repetições dos loops <code>for</code> para um número maior, os
erros se tornarão mais prováveis. O fato de você ver ou não os erros depende um
depende do sistema. Podemos tentar <code>Thread.yield()</code> em vez de <code>Thread.sleep()</code>.</p>
</div>
<div id="LeftYieldThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeftYieldThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>              
            <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>         
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Left"</span><span class="o">);</span>                 
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div id="RightYieldThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RightYieldThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>         
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Right "</span><span class="o">);</span>         
            <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essas novas versões das duas classes basicamente substituíram as chamadas para
<code>Thread.sleep()</code> por chamadas para <code>Thread.yield()</code>. Sem a necessidade de
tratamento de exceções, o código é mais simples, mas trocamos um conjunto de
problemas por outro. Se houver outras threads operando na mesma aplicação, eles
serão agendadas de forma a interferir no padrão de rendimento. Se você estiver
executando esse código em uma máquina
com um único processador e um único núcleo, você terá uma boa chance de
ver algo que corresponda ao resultado esperado. No entanto, se estiver executando
em vários núcleos, tudo ficará confuso. É provável que
a <code>LeftYieldThread</code> esteja sendo executada em um processador com a
<code>RightYieldThread</code> em outro. Nesse caso, nenhuma delas tem concorrência
para ceder.</p>
</div>
<div class="paragraph">
<p>Por fim, vamos dar uma olhada em uma solução de pesquisa de opinião que ainda não é suficiente. Para fazer isso, precisamos de variáveis de estado dentro de cada classe para
para saber se ela foi concluída ou não. Cada thread precisa de uma referência
para a outra thread para fazer consultas, e o programa controlador deve ser atualizado para adicioná-las antes de iniciar as threads.</p>
</div>
<div id="LeftPollingThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeftPollingThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">RightPollingThread</span> <span class="n">right</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRight</span><span class="o">(</span><span class="nc">RightPollingThread</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>          
            <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>            
            <span class="k">while</span><span class="o">(!</span><span class="n">right</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>           
            <span class="n">right</span><span class="o">.</span><span class="na">setDone</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>                     
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Left"</span><span class="o">);</span>                 
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDone</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">done</span><span class="o">;</span> <span class="o">}</span>    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDone</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">done</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div id="RightPollingThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RightPollingThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">LeftPollingThread</span> <span class="n">left</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>   
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLeft</span><span class="o">(</span><span class="nc">LeftPollingThread</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>             
            <span class="k">while</span><span class="o">(!</span><span class="n">left</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>            
            <span class="n">left</span><span class="o">.</span><span class="na">setDone</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>            
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Right "</span><span class="o">);</span>         
            <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDone</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">done</span><span class="o">;</span> <span class="o">}</span>    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDone</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">done</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Seja com um único núcleo ou com vários núcleos, essa solução sempre fornecerá
a saída correta. Ou deveria. Os especialistas em Java apontarão que estamos
violando um aspecto técnico do modelo de memória Java. Como não estamos
usando ferramentas de sincronização, não temos garantia de que a alteração da variável
<code>done</code> será sequer <strong>visível</strong> de uma thread para outra. Na prática, esse
problema raramente o afetará, mas, por segurança, ambas as variáveis
as variáveis <code>done</code> devem ser declaradas com a palavra-chave <code>volatile</code>.
Essa palavra-chave faz com que o Java saiba que o valor pode ser acessado
a qualquer momento por threads arbitrárias.</p>
</div>
<div class="paragraph">
<p>Outro problema é que não há <strong>nenhuma</strong> execução paralela. Cada thread deve esperar
para que o outro seja concluído.É claro que esse problema não se beneficia de
paralelismo, mas aplicar essa solução a problemas que podem se beneficiar do
paralelismo pode causar problemas de desempenho. Cada thread
desperdiça tempo ocupado esperando em um loop <code>while</code> que o outro seja concluído,
consumindo ciclos de CPU enquanto faz isso. Você perceberá que o código
ainda deve ser escrito com cuidado. Cada thread deve definir o valor`done` da
outra thread para <code>false</code>. Se as threads fossem responsáveis por definir seus
próprios valores <code>done</code> para <code>false</code>, uma thread poderia imprimir suas
informações e voltar para o topo da tabela <code>for</code> antes que a outra thread
tivesse redefinido seu próprio <code>done</code> para <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Em resumo, a coordenação de duas ou mais threads é um problema difícil.
Nenhuma das soluções que apresentamos aqui é totalmente aceitável. Nós
apresentamos ferramentas melhores para coordenação e sincronização em
<a href="chap14.html">Chapter 14</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_solução_vírus_mortal">13.8. Solução: Vírus mortal</h3>
<div class="paragraph">
<p>Por fim, apresentamos a solução para o problema do vírus mortal. A essa altura, a
parte da thread desse problema não deve parecer muito difícil.
Ela é mais simples do que alguns dos exemplos, como a multiplicação de matrizes.
Começamos com a classe de trabalho <code>FactorThread</code> que pode ser gerada como uma thread.</p>
</div>
<div id="FactorThreadProgram" class="listingblock">
<div class="title">Programa 13.1 Classe de threads usada para encontrar a soma dos dois fatores de um grande composto ímpar.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactorThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>  
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">upper</span><span class="o">;</span> 
    
    <span class="kd">public</span> <span class="nf">FactorThread</span><span class="o">(</span><span class="kt">long</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">long</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>     
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>     
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">if</span><span class="o">(</span><span class="n">lower</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// Only check odd numbers</span>
            <span class="n">lower</span><span class="o">++;</span>        
        <span class="k">while</span><span class="o">(</span><span class="n">lower</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Factor</span><span class="o">.</span><span class="na">NUMBER</span> <span class="o">%</span> <span class="n">lower</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Security code: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lower</span> <span class="o">+</span> <span class="nc">Factor</span><span class="o">.</span><span class="na">NUMBER</span> <span class="o">/</span> <span class="n">lower</span><span class="o">));</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">lower</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>           
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O construtor do <code>FactorThread</code> recebe um limite superior e um limite inferior,
semelhante ao <code>MatrixThread</code>. Quando um objeto <code>FactorThread</code> tiver esses
limites, ele poderá pesquisar entre eles. O número a ser fatorado é armazenado
na classe <code>Factor</code>. Se qualquer valor dividir esse número igualmente, ele deverá ser
um dos fatores, o que facilita a localização, a soma e a impressão do outro fator,
e imprimir. Temos que adicionar algumas linhas extras de código para garantir que
vamos procurar apenas os números ímpares no intervalo. Essa solução foi ajustada
para eficiência para esse problema específico de segurança. Um programa para
encontrar fatores primos em geral teria de ser mais flexível. A seguir, vamos
examinar o programa controle <code>Factor</code>.</p>
</div>
<div id="FactorProgram" class="listingblock">
<div class="title">Programa 13.2 Classe controle que cria threads para reduzir o tempo médio de pesquisa dos fatores de um grande composto ímpar.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREADS</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">NUMBER</span> <span class="o">=</span> <span class="mi">59984005171248659L</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FactorThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FactorThread</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="kt">long</span> <span class="n">root</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="no">NUMBER</span><span class="o">);</span> <span class="c1">// Go to square root</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>  <span class="c1">// No need to test 2       </span>
        <span class="kt">long</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">root</span> <span class="o">/</span> <span class="no">THREADS</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">root</span> <span class="o">%</span> <span class="no">THREADS</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">work</span> <span class="o">=</span> <span class="n">quotient</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="o">)</span>
                <span class="n">work</span><span class="o">++;</span>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FactorThread</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">work</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">work</span><span class="o">;</span>
        <span class="o">}</span>   
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>As constantes estáticas mantêm o número a ser fatorado e o número de
threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No método <code>main()</code>, criamos uma matriz de threads para
armazenamento.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Em seguida, criamos e iniciamos cada objeto <code>FactorThread</code>, atribuindo limites
superior e inferior ao mesmo tempo, usando a técnica padrão de
<a href="chap6.html#_concurrency_arrays">Section 6.11</a> para dividir o trabalho de forma justa. Como nós
sabemos que o número que estamos dividindo não é par, começamos com 3.
Ao chegar à raiz quadrada do número, sabemos que encontraremos apenas o menor dos
dois fatores. Dessa forma, podemos evitar que uma thread encontre o menor enquanto outro encontra a maior.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Em seguida, temos as chamadas <code>join()</code> usuais para garantir que todas as
threads foram concluídas. Nesse problema, essas chamadas são desnecessárias.
Uma thread imprimirá o código de segurança correto e as outras
procurarão sem sucesso. Se o programa continuar a fazer outro trabalho, talvez seja
precisaríamos deixar as outras threads terminarem ou até mesmo interrompê-las.
Não se esqueça das chamadas <code>join()</code>, pois elas costumam ser muito importantes.</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_resumo">13.9. Resumo</h3>
<div class="paragraph">
<p>Neste capítulo, exploramos
duas estratégias para obter uma solução concorrente para problemas de programação.
Uma estratégia, a decomposição de tarefas, divide uma tarefa em duas ou mais
subtarefas. Essas subtarefas podem então ser empacotadas como threads Java e
executadas em diferentes núcleos de um processador com vários núcleos. Outra estratégia,
decomposição de domínio, divide os dados de entrada em pedaços menores e
permite que diferentes threads trabalhem de forma concorrente em cada pedaço de dados.</p>
</div>
<div class="paragraph">
<p>Uma solução concorrente para um problema de programação pode, às vezes, ser executada mais rapidamente
do que uma solução sequencial. A velocidade mede a eficácia de uma solução concorrente
é eficaz na exploração da arquitetura de um processador com vários núcleos.
Observe que nem todos os programas concorrentes levam a um aumento de
velocidade, pois alguns são executados mais lentamente
do que os sequenciais. Escrever um programa concorrente é um
desafio que nos força a dividir o trabalho e os dados de uma
forma que explore melhor os processadores e o sistema operacional disponível.</p>
</div>
<div class="paragraph">
<p>O Java oferece um rico conjunto de primitivos e elementos sintáticos para escrever
programas concorrentes, mas apenas alguns deles foram apresentados neste
capítulo. Os capítulos seguintes fornecem ferramentas adicionais para
codificar programas concorrentes mais complexos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exercícios">13.10. Exercícios</h3>
<div class="paragraph">
<p><strong>Problemas conceituais</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="threadMethodsExercise"></a> Os métodos <code>start()</code>, <code>run()</code> e <code>join()</code>
são partes essenciais do processo de uso de threads em Java.
Explique a finalidade de cada método.</p>
</li>
<li>
<p><a id="extendingThreadExercise"></a> Qual é a diferença entre
estender a classe <code>Thread</code> e implementar a interface <code>Runnable</code>?
Quando você deve usar uma em vez da outra?</p>
</li>
<li>
<p><a id="sleepAndYieldMethodsExercise"></a> Como o método <code>Thread.sleep()</code> e
o método <code>Thread.yield()</code> afetam o agendamento de threads?</p>
</li>
<li>
<p><a id="mathExpressionTimingExercise"></a> Considere a expressão em
<a href="chap13.html#mathExpressionTasksExample">Exemplo 13.2</a>. Suponha que as operações de multiplicação e
exponenciação exijam 1 e 10 unidades de tempo, respectivamente.
Calcule o número de unidades de tempo necessárias para avaliar a expressão como
em <a href="chap13.html#figure-math_evaluation">Figura 13.2</a>(a) e (b).</p>
</li>
<li>
<p><a id="quad-coreExercise"></a> Suponha que um computador tenha um processador
quad-core. As tarefas em <a href="chap13.html#videoGameTasksExample">Exemplo 13.1</a> e
<a href="chap13.html#mathExpressionTasksExample">Exemplo 13.2</a> podem ser subdivididas para
melhorar o desempenho em quatro núcleos? Por que sim ou por que não?</p>
</li>
<li>
<p><a id="speedupExercise"></a> Considere a definição de velocidade de <a href="#Examples: Concurrency and speedup" class="target-missing">[Examples: Concurrency and speedup]</a>. Vamos supor que você tenha um
trabalho com 1.000.000 de unidades de tamanho. Uma thread pode processar 10.000 unidades de trabalho
a cada segundo. São necessárias 100 unidades adicionais de trabalho para criar uma nova
thread. Qual é o aumento de velocidade se você tiver um processador dual-core e criar
2 threads? E se você tiver um processador quad-core e criar 4 threads?
Ou um processador de 8 núcleos e criar 8 threads? Você pode presumir que uma thread
não precisa se comunicar depois de ter sido criada.</p>
</li>
<li>
<p><a id="speedupLimitationsExercise"></a> Em que situações a velocidade pode ser menor
do que o número de processadores? É possível que o velocidade
seja maior do que o número de processadores?</p>
</li>
<li>
<p><a id="AmdahlLawExercise"></a> A Lei de Amdahl é uma descrição matemática do valor máximo que
você pode melhorar em um sistema melhorando apenas uma parte dele. Uma forma dessa
lei afirma que o aumento máximo de velocidade que pode ser obtido em um
programa paralelo é 1/(1 - <em>P</em>), em que <em>P</em>
é a fração do programa que pode ser paralelizada em um grau arbitrário.
Se 30% do trabalho em um programa puder ser totalmente paralelizado, mas
o restante é totalmente serial, qual é o aumento de velocidade com dois processadores? Quatro?
Oito? Quais são as implicações da Lei de Amdahl?</p>
</li>
<li>
<p><a id="minimumTimeForTasksExercise"></a> Considere a seguinte tabela de tarefas:</p>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle">Tarefa</th>
<th class="tableblock halign-center valign-middle">Tempo</th>
<th class="tableblock halign-center valign-middle">Concorrência</th>
<th class="tableblock halign-left valign-middle">Dependência</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Lavar pratos</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Cozinhar o jantar</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">45</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Lavar pratos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Limpar o quarto</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Limpar o banheiro</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Fazer a tarefa</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Limpar o quarto</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Nessa tabela, a coluna <strong>Tempo</strong> fornece o número de minutos que uma tarefa
leva para ser executada com uma única pessoa, a coluna <strong>Concorrente</strong>
o número máximo de pessoas que podem ser atribuídas a uma tarefa, e a coluna
<strong>Dependência</strong> mostra quais tarefas não podem ser iniciadas até que outras tarefas
tenham sido concluídas. Suponha que as pessoas atribuídas a uma determinada tarefa possam
dividir perfeitamente o trabalho. Em outras palavras, o tempo que uma tarefa leva é o
tempo de uma única pessoa dividido pelo número de pessoas designadas. Qual é o
mínimo de tempo necessário para executar todas as tarefas com apenas uma
pessoa? Qual é o tempo mínimo necessário para executar todas as tarefas
com um número ilimitado de pessoas? Qual é o menor número de
pessoas necessárias para atingir esse tempo mínimo?</p>
</div>
</li>
<li>
<p><a id="sharedThreadVariableExercise"></a> Considere o seguinte trecho de código.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">x</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Considere também este trecho.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Se presumirmos que esses dois trechos de código estão sendo executados em threads
mas que <code>x</code> é uma variável compartilhada, quais são os valores possíveis
que <code>x</code> poderia ter após a execução dos dois trechos? Lembre-se de que a execução
desses trechos pode ser intercalada de <strong>qualquer</strong> maneira.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Práticas de programação</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="pollingArraySumExercise"></a> Implemente novamente o problema de soma de matriz de
<a href="chap13.html#arraySummationExample">Exemplo 13.10</a> usando <code>polling</code> em vez das chamadas <code>join()</code>. Seu programa não deve usar uma única chamada para <code>join()</code>. A votação
não é a maneira ideal de resolver esse problema, mas vale a pena pensar nessa técnica.</p>
</li>
<li>
<p><a id="parallelAudioProcessingExercise"></a> Os compositores geralmente trabalham com várias faixas
de música. Uma faixa pode conter vocais solo, outra bateria, uma terceira violinos, e
assim por diante. Depois de gravar toda a faixa, um engenheiro de mixagem
pode querer aplicar efeitos especiais, como eco, em uma ou mais faixas.</p>
<div class="paragraph">
<p>Para entender como adicionar eco a uma trilha, suponha que a trilha
consiste em uma lista de amostras de áudio. Cada amostra em uma trilha mono (não estéreo)
pode ser armazenada como um <code>double</code> em uma matriz. Para criar um efeito de
co, combinamos o valor atual de uma amostra de áudio com uma amostra de um
tempo fixo anterior. Esse tempo é chamado de parâmetro <em>delay</em>. Variando
o atraso pode produzir ecos longos e curtos.</p>
</div>
<div class="paragraph">
<p>Se as amostras forem armazenadas na matriz <code>in</code> e o parâmetro de atraso for
armazenado na variável <code>delay</code> (medido em número de amostras), o seguinte trecho de código pode ser usado para
criar a matriz <code>out</code> que contém o som com um eco.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">double</span><span class="o">[]</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">in</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">delay</span><span class="o">];</span>
<span class="c1">// Sound before echo starts</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">delay</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">out</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">in</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="c1">// Sound with echo</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">delay</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">out</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">in</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">in</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delay</span><span class="o">];</span>
<span class="c1">// Echo after sound is over</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">out</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">out</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">in</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delay</span><span class="o">];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Os parâmetros <code>a</code> e <code>b</code> são usados para controlar a natureza do eco. Quando
<code>a</code> é <code>1</code> e <code>b</code> é <code>0</code>, não há eco. Quando <code>a</code> é <code>0</code> e <code>b</code> é
<code>1</code>, não há mixagem. Os engenheiros de áudio controlam os valores de <code>a</code>
e <code>b</code> para criar o efeito de eco desejado.</p>
</div>
<div class="paragraph">
<p>Escreva um programa com threads que calcule os valores em <code>out</code> em paralelo
para um número arbitrário de threads.</p>
</div>
</li>
<li>
<p><a id="sleepTimerExercise"></a> Escreva um programa que receba um número de
minutos e segundos como entrada. Nesse programa, implemente um cronômetro usando
chamadas <code>Thread.sleep()</code>. A cada segundo, imprima o tempo restante na
tela. Qual é a precisão do seu cronômetro?</p>
</li>
<li>
<p><a id="parallelPiApproximationExercise"></a> Como você sabe,
<em>π</em> ≈ 3.1416. Um valor mais preciso pode ser encontrado escrevendo um programa
que aproxima a área de um círculo. A área de um círculo pode ser aproximada
pela soma da área dos retângulos que preenchem a curva do
arco do círculo. À medida que a largura do retângulo chega a zero, a
aproximação fica cada vez mais próxima da área real. Se um círculo com raio
<em>r</em> estiver centralizado na origem, sua altura <em>y</em> em uma determinada
distância <em>x</em> é dada pela seguinte fórmula.</p>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/circleHeight.svg" alt="circleHeight" width="15%">
</div>
</div>
<div class="paragraph">
<p>Escreva uma implementação paralela desse problema que divida
partes do arco do círculo entre várias threads e, em seguida, soma os resultados
os resultados depois que todos eles terminarem. Ao definir <em>r</em> = 2, você
precisa somar apenas um quadrante de um círculo para obter <em>π</em>. Você precisará
usar uma largura de retângulo muito pequena para obter uma resposta precisa. Quando
seu programa terminar de ser executado, você poderá comparar seu valor
com <code>Math.PI</code> para verificar a precisão.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Experimentos</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="executionVariationExercise"></a> Use o método <code>currentTimeMillis()</code>
para medir o tempo necessário para executar um trecho de código Java
de execução relativamente longa que você escreveu.
código Java de execução relativamente longa que você
escreveu. Execute seu programa várias vezes e
compare o tempo de execução obtido durante as diferentes
execuções. Por que você acha que os tempos de execução são diferentes?</p>
</li>
<li>
<p><a id="threadOverheadExercise"></a> A sobrecarga de criação de thread é uma
 consideração importante ao escrever programas paralelos eficientes. Escreva
 um programa que cria um grande número de threads que não fazem nada. Teste
quanto tempo leva para criar e unir vários números de threads. Veja se
você pode determinar quanto tempo uma única operação de criação de thread leva em
seu sistema, em média.</p>
</li>
<li>
<p><a id="matrixSpeedupExercise"></a> Crie implementações em série e concorrente
 da multiplicação de matrizes como as descritas em
<a href="chap13.html#matrixMultiplicationExample">Exemplo 13.11</a>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Faça experiências com diferentes tamanhos de matriz e contagens de threads para ver como
o desempenho da aceleração muda.  Se possível, execute seus testes em máquinas
com diferentes números de núcleos ou processadores.</p>
</li>
<li>
<p>Em uma máquina com <em>k</em> &gt; 1 núcleos, qual é a
de velocidade máxima que você pode esperar obter?</p>
</li>
</ol>
</div>
</li>
<li>
<p><a id="executionOrderExercise"></a> Execute repetidamente o código em
<a href="chap13.html#arrayOfThreadsExample">Exemplo 13.7</a> que cria vários objetos
<code>NumberedThread</code>. Você consegue descobrir algum padrão na ordem em
que as threads imprimem? Adicione um loop e alguma instrumentação adicional
à classe <code>NumberedThread</code> que permitirá que você meça quanto tempo
cada thread é executado antes que a próxima thread tenha uma vez.</p>
</li>
<li>
<p><a id="arraySummingSpeedupExercise"></a> Crie implementações seriais e paralelas do
problema de soma de matrizes resolvido em <a href="chap13.html#arraySummationExample">Exemplo 13.10</a>.
Faça experiências com diferentes tamanhos de matriz e contagens de threads para ver como
o desempenho muda. Como o aumento de velocidade difere da multiplicação de matrizes?
O que acontece se você simplesmente somar os números em vez de obter o seno
primeiro?</p>
</li>
<li>
<p><a id="treeSummationExercise"></a> A solução para o problema de soma de matrizes
em <a href="chap13.html#arraySummationExample">Exemplo 13.10</a> parece usar a concorrente
sem entusiasmo. Depois que todas as threads calcularam suas somas, a thread principal
soma as somas parciais sequencialmente.</p>
<div class="paragraph">
<p>Uma abordagem alternativa é somar as somas parciais de forma concorrente. Depois
que uma thread tenha calculado a soma dos senos de cada partição, as somas de
cada par de partições vizinhas devem ser mescladas em uma única
soma. O processo pode ser repetido até que a soma final tenha sido calculada.
Em cada etapa, metade das threads restantes não terá mais nada a fazer
e parará. O padrão de soma é como uma árvore que começa com
<em>k</em> threads trabalhando na primeira etapa,
<em>k</em>/2 trabalhando no segundo estágio,
<em>k</em>/4 trabalhando no terceiro, e assim por diante,
até que uma única thread conclua o processo de soma.</p>
</div>
<div id="figure-tree_summation" class="imageblock">
<div class="content">
<img src="chapters/13-concurrency/images/treesummation.svg" alt="treesummation" width="100%">
</div>
<div class="title">Figura 13.8 Exemplo de soma concorrente em estilo de árvore com 8 threads.</div>
</div>
<div class="paragraph">
<p>Atualize o método <code>run()</code> na classe <code>SumThread</code> para que ele adicione seus
elementos atribuídos como antes e, em seguida, adicione a soma de seu vizinho à sua própria soma.
Para isso, ele deve usar o método <code>join()</code> para aguardar a thread vizinha.
vizinha. Ele deve executar esse processo repetidamente. Após somar seus
valores, cada thread de número par deve adicionar a soma parcial de
seu vizinho. Na próxima etapa, cada thread com um número divisível por 4
deve adicionar a soma parcial de seu vizinho. Na próxima etapa, cada thread
E na etapa seguinte, cada thread com um número divisível por 8 deve adicionar a soma parcial de seu
vizinho, e assim por diante. s thread 0 realizará a soma final.
Consequentemente, a thread principal só precisa esperar pela thread 0. Para que
cada thread possa esperar por outras threads, a matriz <code>threads</code> precisará ser um campo estático.
ser um campo estático. A <a href="chap13.html#figure-tree_summation">Figura 13.8</a> ilustra esse
processo.</p>
</div>
<div class="paragraph">
<p>Depois de implementar esse design, teste-o com a classe <code>SumThread</code>
original para ver o seu desempenho. Restrinja o número de threads
que você criar a uma potência de 2 para facilitar a determinação de
quais threads esperam e quais threads terminam.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div></div>

<nav>
  <a rel="prev" href="chap12.html" class="nav nav-prev" title="Previous page" aria-label="Previous page" aria-keyshortcuts="Left">
        <i class="fa fa-angle-left"></i>
     </a>
  <a rel="next" href="chap14.html" class="nav nav-next" title="Next page" aria-label="Next page" aria-keyshortcuts="Right">
        <i class="fa fa-angle-right"></i>
     </a>
  <div style="clear: both"></div>
</nav>
<div id="footer">
<div id="footer-text">
Last updated 2024-05-20 18:00:47 -0300
</div>
</div>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VEDGKRPMMK"></script>
          <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-VEDGKRPMMK');
          </script>

</body>
  <script>
  function isInViewport(ele) {
    const rect = ele.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    );
  }
  function yPosition (ele) {
    const rect = ele.getBoundingClientRect();
    return (rect.top - 20); // 20px above
  }
  let curr = document.getElementsByClassName('current');
  if (!isInViewport(curr[curr.length - 1])) {
    document.getElementById('toc').scrollTo({
      top: yPosition(curr[0]),
      left: 0,
      behavior: 'smooth'
    });
  }

  /* For page navigation */
  function gotoPage(selector) {
    const button = document.querySelector(selector);
    if (button)
      window.location.href = button.href;
  }
  document.addEventListener('keydown', e => {
    if (e.shiftKey)
      return;
    switch (e.key) {
      case 'ArrowRight':
        e.preventDefault();
        gotoPage('.nav-next');
        break;
      case 'ArrowLeft':
        e.preventDefault();
        gotoPage('.nav-prev');
        break;
    }
  });
  </script>
  </html>