<!DOCTYPE html><html lang="pt_BR"><head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<meta name="author" content="Barry Wittman, Tim Korb, Aditya Mathur">
<title>Começando Concorrente: Uma Introdução Gentil à Programação Concorrente</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="style0.css" type="text/css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="style1.css" type="text/css">
<link rel="stylesheet" href="asciidoctor-chunker.css" type="text/css"></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Começando Concorrente: Uma Introdução Gentil à Programação Concorrente</h1>
<div class="details">
<span id="author" class="author">Barry Wittman</span><br>
<span id="email" class="email"><a href="mailto:wittman1@otterbein.edu">wittman1@otterbein.edu</a></span><br>
<span id="author2" class="author">Tim Korb</span><br>
<span id="email2" class="email"><a href="mailto:jtk@purdue.edu">jtk@purdue.edu</a></span><br>
<span id="author3" class="author">Aditya Mathur</span><br>
<span id="email3" class="email"><a href="mailto:apm@purdue.edu">apm@purdue.edu</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<ul class="sectlevel1">
<li><a href="index.html">Começando Concorrente</a></li><li><a href="index.html">1. Computer Basics</a>
<ul class="sectlevel2">
<li><a href="index.html#_problem_buying_a_computer">1.1. Problem: Buying a computer</a></li>
<li><a href="index.html#_concepts_hardware_and_software">1.2. Concepts: Hardware and software</a></li>
<li><a href="index.html#_syntax_data_representation">1.3. Syntax: Data representation</a></li>
<li><a href="index.html#_solution_buying_a_computer">1.4. Solution: Buying a computer</a></li>
<li><a href="index.html#_summary">1.5. Summary</a></li>
<li><a href="index.html#_exercises">1.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap2.html">2. Problem Solving and Programming</a>
<ul class="sectlevel2">
<li><a href="chap2.html#_problem_how_to_solve_problems">2.1. Problem: How to solve problems</a></li>
<li><a href="chap2.html#_concepts_developing_software">2.2. Concepts: Developing software</a></li>
<li><a href="chap2.html#_syntax_java_basics">2.3. Syntax: Java basics</a></li>
<li><a href="chap2.html#_solution_how_to_solve_problems">2.4. Solution: How to solve problems</a></li>
<li><a href="chap2.html#_concurrency_solving_problems_in_parallel">2.5. Concurrency: Solving problems in parallel</a></li>
<li><a href="chap2.html#_summary_2">2.6. Summary</a></li>
<li><a href="chap2.html#_exercises_2">2.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap3.html">3. Primitive Types and Strings</a>
<ul class="sectlevel2">
<li><a href="chap3.html#_problem_college_cost_calculator">3.1. Problem: College cost calculator</a></li>
<li><a href="chap3.html#_concepts_types">3.2. Concepts: Types</a></li>
<li><a href="chap3.html#_syntax_types_in_java">3.3. Syntax: Types in Java</a></li>
<li><a href="chap3.html#_syntax_useful_libraries">3.4. Syntax: Useful libraries</a></li>
<li><a href="chap3.html#_solution_college_cost_calculator">3.5. Solution: College cost calculator</a></li>
<li><a href="chap3.html#_concurrency_expressions">3.6. Concurrency: Expressions</a></li>
<li><a href="chap3.html#_summary_3">3.7. Summary</a></li>
<li><a href="chap3.html#_exercises_3">3.8. Exercises</a></li>
</ul>
</li>
<li><a href="chap4.html">4. Selection</a>
<ul class="sectlevel2">
<li><a href="chap4.html#_problem_monty_hall_simulation">4.1. Problem: Monty Hall simulation</a></li>
<li><a href="chap4.html#_concepts_choosing_between_options">4.2. Concepts: Choosing between options</a></li>
<li><a href="chap4.html#_syntax_selection_in_java">4.3. Syntax: Selection in Java</a></li>
<li><a href="chap4.html#_solution_monty_hall">4.4. Solution: Monty Hall</a></li>
<li><a href="chap4.html#_concurrency_selection">4.5. Concurrency: Selection</a></li>
<li><a href="chap4.html#_exercises_4">4.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap5.html">5. Repetition</a>
<ul class="sectlevel2">
<li><a href="chap5.html#_problem_dna_searching">5.1. Problem: DNA searching</a></li>
<li><a href="chap5.html#_concepts_repetition">5.2. Concepts: Repetition</a></li>
<li><a href="chap5.html#_syntax_loops_in_java">5.3. Syntax: Loops in Java</a></li>
<li><a href="chap5.html#_solution_dna_searching">5.4. Solution: DNA searching</a></li>
<li><a href="chap5.html#_concurrency_loops">5.5. Concurrency: Loops</a></li>
<li><a href="chap5.html#_exercises_5">5.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap6.html">6. Arrays</a>
<ul class="sectlevel2">
<li><a href="chap6.html#_introduction">6.1. Introduction</a></li>
<li><a href="chap6.html#_problem_game_of_life">6.2. Problem: Game of Life</a></li>
<li><a href="chap6.html#_concepts_lists_of_data">6.3. Concepts: Lists of data</a></li>
<li><a href="chap6.html#_syntax_arrays_in_java">6.4. Syntax: Arrays in Java</a></li>
<li><a href="chap6.html#_examples_array_usage">6.5. Examples: Array usage</a></li>
<li><a href="chap6.html#_concepts_multidimensional_lists">6.6. Concepts: Multidimensional lists</a></li>
<li><a href="chap6.html#_syntax_advanced_arrays_in_java">6.7. Syntax: Advanced arrays in Java</a></li>
<li><a href="chap6.html#_examples_two_dimensional_arrays">6.8. Examples: Two-dimensional arrays</a></li>
<li><a href="chap6.html#_advanced_special_array_tools_in_java">6.9. Advanced: Special array tools in Java</a></li>
<li><a href="chap6.html#_solution_game_of_life">6.10. Solution: Game of Life</a></li>
<li><a href="chap6.html#_concurrency_arrays">6.11. Concurrency: Arrays</a></li>
<li><a href="chap6.html#_exercises_6">6.12. Exercises</a></li>
</ul>
</li>
<li><a href="chap7.html">7. Simple Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap7.html#_problem_codon_extractor">7.1. Problem: Codon extractor</a></li>
<li><a href="chap7.html#GUIBasicsIntroductionSection">7.2. Concepts: User interaction</a></li>
<li><a href="chap7.html#_syntax_dialogs_and_the_joptionpane_class">7.3. Syntax: Dialogs and the <code>JOptionPane</code> class</a></li>
<li><a href="chap7.html#_solution_codon_extractor">7.4. Solution: Codon extractor</a></li>
<li><a href="chap7.html#_concurrency_simple_guis">7.5. Concurrency: Simple GUIs</a></li>
<li><a href="chap7.html#_summary_4">7.6. Summary</a></li>
<li><a href="chap7.html#_exercises_7">7.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap8.html">8. Methods</a>
<ul class="sectlevel2">
<li><a href="chap8.html#_problem_three_card_poker">8.1. Problem: Three card poker</a></li>
<li><a href="chap8.html#_concepts_dividing_work_into_segments">8.2. Concepts: Dividing work into segments</a></li>
<li><a href="chap8.html#_syntax_methods">8.3. Syntax: Methods</a></li>
<li><a href="chap8.html#_examples_defining_methods">8.4. Examples: Defining methods</a></li>
<li><a href="chap8.html#_solution_three_card_poker">8.5. Solution: Three card poker</a></li>
<li><a href="chap8.html#_concurrency_methods">8.6. Concurrency: Methods</a></li>
<li><a href="chap8.html#_exercises_8">8.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap9.html">9. Classes</a>
<ul class="sectlevel2">
<li><a href="chap9.html#_problem_nested_expressions">9.1. Problem: Nested expressions</a></li>
<li><a href="chap9.html#_concepts_object_oriented_programming">9.2. Concepts: Object-oriented programming</a></li>
<li><a href="chap9.html#_syntax_classes_in_java">9.3. Syntax: Classes in Java</a></li>
<li><a href="chap9.html#_advanced_nested_classes">9.4. Advanced: Nested classes</a></li>
<li><a href="chap9.html#_solution_nested_expressions">9.5. Solution: Nested expressions</a></li>
<li><a href="chap9.html#_concurrency_objects">9.6. Concurrency: Objects</a></li>
<li><a href="chap9.html#_exercises_9">9.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap10.html">10. Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap10.html#_problem_sort_it_out">10.1. Problem: Sort it out</a></li>
<li><a href="chap10.html#_concepts_making_a_promise">10.2. Concepts: Making a promise</a></li>
<li><a href="chap10.html#_syntax_interfaces">10.3. Syntax: Interfaces</a></li>
<li><a href="chap10.html#_advanced_local_and_anonymous_classes">10.4. Advanced: Local and anonymous classes</a></li>
<li><a href="chap10.html#_solution_sort_it_out">10.5. Solution: Sort it out</a></li>
<li><a href="chap10.html#_concurrency_interfaces">10.6. Concurrency: Interfaces</a></li>
<li><a href="chap10.html#_exercises_10">10.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap11.html">11. Inheritance</a>
<ul class="sectlevel2">
<li><a href="chap11.html#_problem_boolean_circuits">11.1. Problem: Boolean circuits</a></li>
<li><a href="chap11.html#_concepts_refining_classes">11.2. Concepts: Refining classes</a></li>
<li><a href="chap11.html#_syntax_inheritance_in_java">11.3. Syntax: Inheritance in Java</a></li>
<li><a href="chap11.html#_examples_problem_solving_with_inheritance">11.4. Examples: Problem solving with inheritance</a></li>
<li><a href="chap11.html#_solution_boolean_circuits">11.5. Solution: Boolean circuits</a></li>
<li><a href="chap11.html#_concurrency_inheritance">11.6. Concurrency: Inheritance</a></li>
<li><a href="chap11.html#_exercises_11">11.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap12.html">12. Exceptions</a>
<ul class="sectlevel2">
<li><a href="chap12.html#_problem_bank_burglary">12.1. Problem: Bank burglary</a></li>
<li><a href="chap12.html#_concepts_error_handling">12.2. Concepts: Error handling</a></li>
<li><a href="chap12.html#_syntax_exceptions_in_java">12.3. Syntax: Exceptions in Java</a></li>
<li><a href="chap12.html#_solution_bank_burglary">12.4. Solution: Bank burglary</a></li>
<li><a href="chap12.html#_concurrency_exceptions">12.5. Concurrency: Exceptions</a></li>
<li><a href="chap12.html#_exercises_12">12.6. Exercises</a></li>
</ul>
</li>
<li class="current"><a href="chap13.html">13. Programação Concorrente</a>
<ul class="sectlevel2">
<li class="current"><a href="chap13.html#_introdução">13.1. Introdução</a></li>
<li class="current"><a href="chap13.html#_problema_vírus_mortal">13.2. Problema: Vírus mortal</a></li>
<li class="current"><a href="chap13.html#_conceitos_dividindo_para_conquistar">13.3. Conceitos: Dividindo para conquistar</a></li>
<li class="current"><a href="chap13.html#_sintaxe_threads_em_java">13.4. Sintaxe: Threads em Java</a></li>
<li class="current"><a href="chap13.html#_exemplos_concorrência_e_aceleração">13.5. Exemplos: Concorrência e aceleração</a></li>
<li class="current"><a href="chap13.html#_concepts_thread_scheduling">13.6. Concepts: Thread scheduling</a></li>
<li class="current"><a href="chap13.html#_syntax_thread_states">13.7. Syntax: Thread states</a></li>
<li class="current"><a href="chap13.html#_solution_deadly_virus">13.8. Solution: Deadly virus</a></li>
<li class="current"><a href="chap13.html#_summary_5">13.9. Summary</a></li>
<li class="current"><a href="chap13.html#_exercises_13">13.10. Exercises</a></li>
</ul>
</li>
<li><a href="chap14.html">14. Synchronization</a>
<ul class="sectlevel2">
<li><a href="chap14.html#_introduction_2">14.1. Introduction</a></li>
<li><a href="chap14.html#_problem_dining_philosophers">14.2. Problem: Dining philosophers</a></li>
<li><a href="chap14.html#_concepts_thread_interaction">14.3. Concepts: Thread interaction</a></li>
<li><a href="chap14.html#_syntax_thread_synchronization">14.4. Syntax: Thread synchronization</a></li>
<li><a href="chap14.html#_pitfalls_synchronization_challenges">14.5. Pitfalls: Synchronization challenges</a></li>
<li><a href="chap14.html#_solution_dining_philosophers">14.6. Solution: Dining philosophers</a></li>
<li><a href="chap14.html#_exercises_14">14.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap15.html">15. Constructing Graphical User Interfaces</a>
<ul class="sectlevel2">
<li><a href="chap15.html#_problem_math_tutor">15.1. Problem: Math tutor</a></li>
<li><a href="chap15.html#_concepts_graphical_user_interfaces">15.2. Concepts: Graphical user interfaces</a></li>
<li><a href="chap15.html#_syntax_guis_in_java">15.3. Syntax: GUIs in Java</a></li>
<li><a href="chap15.html#_solution_math_tutor">15.4. Solution: Math tutor</a></li>
<li><a href="chap15.html#_concurrency_guis">15.5. Concurrency: GUIs</a></li>
<li><a href="chap15.html#_summary_6">15.6. Summary</a></li>
<li><a href="chap15.html#_exercises_15">15.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap16.html">16. Testing and Debugging</a>
<ul class="sectlevel2">
<li><a href="chap16.html#_fixing_bugs">16.1. Fixing bugs</a></li>
<li><a href="chap16.html#_concepts_approaches_to_debugging">16.2. Concepts: Approaches to debugging</a></li>
<li><a href="chap16.html#_syntax_java_debugging_tools">16.3. Syntax: Java debugging tools</a></li>
<li><a href="chap16.html#_concurrency_parallel_bugs">16.4. Concurrency: Parallel bugs</a></li>
<li><a href="chap16.html#_finding_and_avoiding_bugs">16.5. Finding and avoiding bugs</a></li>
<li><a href="chap16.html#_concepts_design_implementation_and_testing">16.6. Concepts: Design, implementation, and testing</a></li>
<li><a href="chap16.html#_syntax_java_testing_tools">16.7. Syntax: Java testing tools</a></li>
<li><a href="chap16.html#_concurrency_testing_tools">16.8. Concurrency: Testing tools</a></li>
<li><a href="chap16.html#_examples_testing_a_class">16.9. Examples: Testing a class</a></li>
<li><a href="chap16.html#_exercises_16">16.10. Exercises</a></li>
</ul>
</li>
<li><a href="chap17.html">17. Polymorphism</a>
<ul class="sectlevel2">
<li><a href="chap17.html#_problem_banking_account_with_a_vengeance">17.1. Problem: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concepts_polymorphism">17.2. Concepts: Polymorphism</a></li>
<li><a href="chap17.html#_syntax_inheritance_tools_in_java">17.3. Syntax: Inheritance tools in Java</a></li>
<li><a href="chap17.html#_solution_banking_account_with_a_vengeance">17.4. Solution: Banking account with a vengeance</a></li>
<li><a href="chap17.html#_concurrency_atomic_libraries">17.5. Concurrency: Atomic libraries</a></li>
<li><a href="chap17.html#_exercises_17">17.6. Exercises</a></li>
</ul>
</li>
<li><a href="chap18.html">18. Dynamic Data Structures</a>
<ul class="sectlevel2">
<li><a href="chap18.html#_problem_infix_conversion">18.1. Problem: Infix conversion</a></li>
<li><a href="chap18.html#_concepts_dynamic_data_structures">18.2. Concepts: Dynamic data structures</a></li>
<li><a href="chap18.html#_syntax_dynamic_arrays_and_linked_lists">18.3. Syntax: Dynamic arrays and linked lists</a></li>
<li><a href="chap18.html#_syntax_abstract_data_types_adt">18.4. Syntax: Abstract data types (ADT)</a></li>
<li><a href="chap18.html#_advanced_generic_data_structures">18.5. Advanced: Generic data structures</a></li>
<li><a href="chap18.html#_solution_infix_conversion">18.6. Solution: Infix conversion</a></li>
<li><a href="chap18.html#_concurrency_linked_lists_and_thread_safety">18.7. Concurrency: Linked lists and thread safety</a></li>
<li><a href="chap18.html#_concurrency_thread_safe_libraries">18.8. Concurrency: Thread-safe libraries</a></li>
<li><a href="chap18.html#_exercises_18">18.9. Exercises</a></li>
</ul>
</li>
<li><a href="chap19.html">19. Recursion</a>
<ul class="sectlevel2">
<li><a href="chap19.html#_problem_maze_of_doom">19.1. Problem: Maze of doom</a></li>
<li><a href="chap19.html#_concepts_recursive_problem_solving">19.2. Concepts: Recursive problem solving</a></li>
<li><a href="chap19.html#_syntax_recursive_methods">19.3. Syntax: Recursive methods</a></li>
<li><a href="chap19.html#_syntax_recursive_data_structures">19.4. Syntax: Recursive data structures</a></li>
<li><a href="chap19.html#_solution_maze_of_doom">19.5. Solution: Maze of doom</a></li>
<li><a href="chap19.html#_concurrency_futures">19.6. Concurrency: Futures</a></li>
<li><a href="chap19.html#_exercises_19">19.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap20.html">20. File I/O</a>
<ul class="sectlevel2">
<li><a href="chap20.html#_problem_a_picture_is_worth_1000_bytes">20.1. Problem: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concepts_file_io">20.2. Concepts: File I/O</a></li>
<li><a href="chap20.html#_syntax_file_operations_in_java">20.3. Syntax: File operations in Java</a></li>
<li><a href="chap20.html#_examples_file_examples">20.4. Examples: File examples</a></li>
<li><a href="chap20.html#fileChapterSolution">20.5. Solution: A picture is worth 1,000 bytes</a></li>
<li><a href="chap20.html#_concurrency_file_io">20.6. Concurrency: File I/O</a></li>
<li><a href="chap20.html#_exercises_20">20.7. Exercises</a></li>
</ul>
</li>
<li><a href="chap21.html">21. Network Communication</a>
<ul class="sectlevel2">
<li><a href="chap21.html#_problem_web_server">21.1. Problem: Web server</a></li>
<li><a href="chap21.html#_concepts_tcpip_communication">21.2. Concepts: TCP/IP communication</a></li>
<li><a href="chap21.html#_syntax_networking_in_java">21.3. Syntax: Networking in Java</a></li>
<li><a href="chap21.html#_solution_web_server">21.4. Solution: Web server</a></li>
<li><a href="chap21.html#_concurrency_networking">21.5. Concurrency: Networking</a></li>
<li><a href="chap21.html#_exercises_21">21.6. Exercises</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">





















<div class="sect1">
<h2 id="ch13-concurrency">13. Programação Concorrente</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>O tempo é a substância da qual sou feito. O tempo é um rio que me arrasta, mas
eu sou o rio; é um tigre que me devora, mas eu sou o tigre; é um fogo que me
consome, mas eu sou o fogo.</p>
</div>
</blockquote>
<div class="attribution">
— Jorge Luis Borges
</div>
</div>
<div class="sect2">
<h3 id="_introdução">13.1. Introdução</h3>
<div class="paragraph">
<p>Até agora, nos concentramos principalmente em escrever programas sequenciais. A
execução sequencial significa que as instruções do programa são executadas uma
de cada vez em uma sequência determinada pela lógica do programa e pelos dados
de entrada. No entanto, mais de uma instrução de programa pode ser executada
independentemente por um processador multicore. Embora seja comum os programadores
escreverem programas sequenciais, a disponibilidade generalizada de processadores
de vários núcleos em um único computador levou a um aumento na demanda por
programadores que possam escrever programas concorrentes.</p>
</div>
<div class="paragraph">
<p>Um programa concorrente é aquele em que várias instruções podem ser executadas
simultaneamente por dois ou mais núcleos. Neste capítulo, mostramos como escrever
programas concorrentes simples em Java que exploram o poder de um computador com
vários núcleos. Começamos com um problema em que o destino do planeta está em
grave perigo!</p>
</div>
</div>
<div class="sect2">
<h3 id="_problema_vírus_mortal">13.2. Problema: Vírus mortal</h3>
<div class="paragraph">
<p>Um vírus mortal capaz de exterminar a população mundial está prestes a ser liberado
por um gênio do mal. Somente ele sabe o código de segurança que pode interromper a
contagem regressiva.  O mundo está condenado. A única esperança de salvação está em
você e em suas habilidades de programação em Java. Por meio das investigações de uma
rede de espionagem ultrassecreta e financiada pelo governo, foi revelado que o código
de segurança está vinculado ao número 59.984.005.171.248.659. Esse grande número é
o produto de dois números primos, e o código de segurança é a soma deles. Tudo o que
você precisa fazer é fatorar o número 59.984.005.171.248.659 em seus dois fatores
primos e somá-los.</p>
</div>
<div class="paragraph">
<p>É claro que há uma pegadinha.  O vírus mortal será lançado em breve, tão em breve que
talvez não haja tempo suficiente para seu computador pesquisar todos os números um a
um. Em vez disso, você deve usar a concorrência para verificar mais de um número por vez.</p>
</div>
<div class="paragraph">
<p>Esse problema parece artificial?  Para manter a privacidade das informações enviadas
pela Internet, muitos tipos de criptografia de chave pública dependem da dificuldade
de fatorar números grandes. Embora a fatoração do número nesse problema não seja
difícil, os números usados para criptografia de chave pública, geralmente com mais de
300 dígitos decimais, resistem à fatoração até mesmo pelos computadores mais rápidos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conceitos_dividindo_para_conquistar">13.3. Conceitos: Dividindo para conquistar</h3>
<div class="paragraph">
<p>O problema do vírus mortal tem uma grande tarefa (fatorar um número) a ser executada.
Como devemos dividir essa tarefa para que possamos realizá-la mais rapidamente? Dividir
o trabalho a ser feito é o cerne de qualquer solução simultânea para um problema.</p>
</div>
<div class="paragraph">
<p>Em um processador com vários núcleos, cada núcleo é um trabalhador independente. É
preciso algum cuidado para coordenar esses trabalhadores. Antes de tudo, ainda precisamos
obter a resposta correta. Uma solução concorrente não tem valor se estiver incorreta
e, ao ler e gravar na mesma memória compartilhada, as respostas encontradas por um
núcleo podem corromper as respostas encontradas por outros núcleos. A prevenção desse
problema será abordada no <a href="chap14.html">Chapter 14</a>. Quando pudermos
garantir que a solução concorrente está correta, também vamos querer melhorar o desempenho.
Talvez queiramos que a tarefa seja concluída mais rapidamente. Talvez tenhamos um sistema
interativo que deva continuar a lidar com as solicitações dos usuários mesmo que esteja
trabalhando em uma solução em segundo plano. Novamente, se a sobrecarga de coordenar nossos
trabalhadores levar mais tempo do que uma solução sequencial ou tornar o sistema menos
responsivo, isso não será útil.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#sharedThreadVariableExercise">Exercício 13.10</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Há duas maneiras principais de dividir o trabalho. A primeira é chamada de <em>decomposição
de tarefas</em>. Nessa abordagem, cada funcionário recebe uma tarefa diferente para fazer. A
segunda é chamada de <em>decomposição de domínio</em>. Nessa abordagem, os funcionários fazem o
mesmo trabalho, mas com dados diferentes.</p>
</div>
<div class="paragraph">
<p>É possível usar tanto a decomposição de tarefas quanto a de domínios para resolver o mesmo
problema. Com os dois tipos de decomposição, geralmente é necessário coordenar os
trabalhadores para que possam compartilhar informações. Nas próximas duas subseções,
descreveremos com mais detalhes a decomposição de tarefas e a decomposição de domínios.
Em seguida, discutiremos o mapeamento de tarefas para <em>threads</em> de execução e as diferentes
arquiteturas de memória que podem ser usadas para programação simultânea.</p>
</div>
<div class="sect3">
<h4 id="_decomposição_de_tarefas">13.3.1. Decomposição de tarefas</h4>
<div class="paragraph">
<p>A ideia de dividir uma tarefa em subtarefas menores é natural. Imagine que você está
planejando um jantar. Você precisa comprar suprimentos, preparar o jantar, limpar a casa
e arrumar a mesa. Se quatro de vocês estivessem planejando a festa, cada um poderia
realizar uma atividade separada. Os preparativos poderiam ser muito mais rápidos do que
se uma única pessoa estivesse fazendo o trabalho, mas a coordenação ainda é importante.
Talvez a pessoa que estiver preparando o jantar não possa terminar até que certos
suprimentos sejam comprados.</p>
</div>
<div class="paragraph">
<p>A decomposição de tarefas geralmente é mais fácil do que a decomposição de domínios porque
muitas tarefas têm divisões naturais. Infelizmente, essa nem sempre é uma maneira eficaz de
usar vários núcleos em um computador. Se uma tarefa for concluída muito antes das outras,
um núcleo poderá ficar ocioso.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#minimumTimeForTasksExercise">Exercício 13.9</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Os dois exemplos a seguir mostram ilustrações simples do processo de divisão de uma tarefa em subtarefas menores no contexto da programação multicore.</p>
</div>
<div id="videoGameTasksExample" class="exampleblock">
<div class="title">Exemplo 13.1 Tarefas de videogame</div>
<div class="content">
<div class="paragraph">
<p>Considere um videogame simples que consiste nas seguintes tarefas</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Iniciar o jogo</p>
</li>
<li>
<p>Processar a jogada</p>
</li>
<li>
<p>Atualizar pontuação</p>
</li>
<li>
<p>Repintar a tela</p>
</li>
<li>
<p>Encerrar o jogo</p>
</li>
</ol>
</div>
<div id="figure-video_game_tasks" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/video-game-tasks.svg" alt="video game tasks" width="75%">
</div>
<div class="title">Figura 13.1 Execução de tarefas em um vídeogame. (a) Execução sequencial em um núcleo. (b) Execução concorrente em dois núcleos. As setas indicam o fluxo de execução e de transferência de dados.</div>
</div>
<div class="paragraph">
<p>Suponha que as tarefas B e D sejam independentes e possam ser executadas simultaneamente se houver dois núcleos disponíveis. A tarefa D atualiza continuamente a tela com os dados antigos até que a tarefa C atualize as informações.</p>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-video_game_tasks">Figura 13.1</a>(a) e (b) mostram como as tarefas desse videogame podem ser sequenciadas, respectivamente, em um único núcleo ou em dois núcleos. Todas as tarefas são executadas sequencialmente em um processador de núcleo único. Em um processador de núcleo duplo, as tarefas B e C podem ser executadas em um núcleo enquanto a tarefa D é executada simultaneamente em outro. Observe na figura que a tarefa C envia a pontuação e qualquer outros dados para a tarefa D, que atualiza continuamente a tela. Ter dois núcleos pode permitir uma atualização mais rápida da tela, pois o processador não precisa esperar que as tarefas B ou C sejam concluídas.</p>
</div>
</div>
</div>
<div id="mathExpressionTasksExample" class="exampleblock">
<div class="title">Exemplo 13.2 Tarefas de expressão matemática</div>
<div class="content">
<div class="paragraph">
<p>Suponha que precisemos avaliar a expressão matemática 2<em>Kate</em><sup>-⁠<em>at</em>²</sup> com os parâmetros <em>a</em> e <em>K</em> em um determinado valor de <em>t</em>. Podemos dividir a expressão em dois termos: 2<em>Kat</em> e <em>e</em><sup>-⁠<em>at</em>²</sup>. Cada um desses termos pode ser atribuído a uma tarefa diferente para avaliação. Em um processador de dois núcleos, essas duas tarefas podem ser executadas em núcleos separados e os resultados de cada uma delas podem ser combinados para encontrar o valor da expressão para a tarefa principal.</p>
</div>
<div id="figure-math_evaluation" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/mathematical-expression-evaluation.svg" alt="mathematical expression evaluation" width="75%">
</div>
<div class="title">Figura 13.2 Avaliação de uma expressão matemática (a) sequencialmente em um único núcleo e (b) simultaneamente em dois núcleos. As setas mostram o fluxo de execução e a transferência de dados. A fonte em destaque indica a operação que está sendo executada.</div>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-math_evaluation">Figura 13.2</a> mostra como essa expressão pode ser avaliada em processadores de um núcleo e de dois núcleos. Às vezes, o uso de vários núcleos para avaliar uma expressão como essa levará menos tempo do que um único núcleo. No entanto, não há garantia de que o uso de vários núcleos sempre será mais rápido, pois as tarefas levam tempo para serem configuradas e para se comunicarem entre si.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#mathExpressionTimingExercise">Exercício 13.4</a><br>
<a href="chap13.html#quad-coreExercise">Exercício 13.5</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Esses exemplos ilustram como uma tarefa pode ser dividida em duas ou mais subtarefas executadas por diferentes núcleos de um processador. Usamos um processador dual-core em nossos exemplos, mas as mesmas ideias podem ser expandidas para um número maior de núcleos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_decomposição_de_domínio">13.3.2. Decomposição de domínio</h4>
<div class="paragraph">
<p>Em um programa de computador, cada tarefa executa operações em dados. Esses dados são chamados de <em>domínio</em> dessa tarefa. Na decomposição do domínio, os dados são divididos em partes menores, em que cada parte é atribuída a um núcleo diferente, em vez de dividir uma tarefa em subtarefas. Assim, cada núcleo executa a mesma tarefa, mas em dados diferentes.</p>
</div>
<div class="paragraph">
<p>No exemplo do jantar, poderíamos ter usado a decomposição de domínio em vez de (ou além de) decomposição de tarefa. Se quiser cozinhar uma grande quantidade de purê de batatas, você mesmo pode descascar 24 batatas. Entretanto, se houver quatro pessoas (e cada uma delas tiver um descascador de batatas), cada pessoa precisará descascar apenas 6 batatas.</p>
</div>
<div class="paragraph">
<p>A estratégia de decomposição de domínio é muito útil e é um dos principais focos da simultaneidade neste livro. Os problemas da computação moderna geralmente usam dados maciços, que incluem milhões de valores ou milhares de registros de bancos de dados. Escrever programas que possam dividir os dados de modo que vários núcleos possam processar seções menores pode acelerar muito o tempo necessário para concluir o cálculo.</p>
</div>
<div class="paragraph">
<p>De certa forma, a decomposição de domínios pode ser mais difícil do que a decomposição de tarefas. Os dados devem ser divididos de maneira uniforme e justa. Depois que cada seção de dados tiver sido processada, os resultados deverão ser combinados. Empresas como o Google, que processam grandes quantidades de informações, desenvolveram uma terminologia para descrever esse processo. Dividir os dados e atribuí-los aos funcionários é chamado de etapa do mapa (<em>map</em>). A combinação das respostas parciais na resposta final é chamada de etapa de redução (<em>reduce</em>).</p>
</div>
<div class="paragraph">
<p>Ilustramos a estratégia de decomposição de domínio nos dois exemplos a seguir.</p>
</div>
<div id="arraySummationPreviewExample" class="exampleblock">
<div class="title">Exemplo 13.3 Visualização da soma de matrizes</div>
<div class="content">
<div class="paragraph">
<p>Suponha que queiramos aplicar a função <em>f</em> a cada elemento
de uma matriz <em>a</em> e somar os resultados. Matematicamente, queremos calcular a seguinte soma.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/oneCoreSum.svg" alt="oneCoreSum" width="15%">
</div>
</div>
<div class="paragraph">
<p>Nessa fórmula, <em>a</em><sub><em>i</em></sub> é o <em>i</em><sup>ésimo</sup> elemento da matriz <em>a</em>. Vamos supor que temos um processador dual-core disponível para calcular a soma. Dividimos a matriz de modo que cada núcleo execute a tarefa em metade da matriz. Sejam <em>S</em><sub>1</sub> e <em>S</em><sub>2</sub> denotem as somas calculadas pelo núcleo 1 e pelo núcleo 2, respectivamente.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/twoCoreSum.svg" alt="twoCoreSum" width="50%">
</div>
</div>
<div class="paragraph">
<p>Supondo que <em>N</em> seja uniforme, os dois núcleos processam exatamente a
mesma quantidade de dados. Para <em>N</em> ímpar, um dos núcleos processa
um item de dados a mais do que o outro.</p>
</div>
<div id="figure-array_decomposition" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/arrayDecomposition.svg" alt="arrayDecomposition" width="60%">
</div>
<div class="title">Figura 13.3 Calculando a soma de uma função de cada elemento de uma matriz.</div>
</div>
<div class="paragraph">
<p>Depois que <em>S</em><sub>1</sub> e <em>S</em><sub>2</sub> tiverem sido computados, um dos
núcleos pode somar esses dois números para obter <em>S</em>.
Essa estratégia é ilustrada em <a href="chap13.html#figure-array_decomposition">Figura 13.3</a>.
Depois que os dois núcleos tiverem concluído seu trabalho em cada metade da matriz,
as somas individuais são então somadas para produzir o resultado final.</p>
</div>
</div>
</div>
<div id="matrixMultiplicationPreviewExample" class="exampleblock">
<div class="title">Exemplo 13.4 Visualização da multiplicação de matrizes</div>
<div class="content">
<div class="paragraph">
<p>A necessidade de multiplicar matrizes surge em muitas aplicações matemáticas, científicas e de engenharia. Suponha que nos peçam para escrever um programa para
multiplicar duas matrizes quadradas <em>A</em> e <em>B</em>, que
são ambas matrizes <em>n</em> × <em>n</em>. A matriz do produto
<em>C</em> também será <em>n</em> × <em>n</em>. Um programa
sequencial calculará cada elemento da matriz <em>C</em> um de cada vez.
vez. Entretanto, um programa simultâneo pode calcular mais de um elemento de
<em>C</em> simultaneamente usando vários núcleos.</p>
</div>
<div id="figure-matrix_decomposition" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/matrixDecomposition.svg" alt="matrixDecomposition" width="75%">
</div>
<div class="title">Figura 13.4 Decomposição de dados para multiplicar duas matrizes 4 × 4. Os dois núcleos executam as mesmas tarefas de multiplicação, mas em dados diferentes da matriz <em>A</em>.Os dois núcleos calculam as duas linhas superiores e as duas linhas inferiores de <em>C</em>, respectivamente.</div>
</div>
<div class="paragraph">
<p>Neste problema, a tarefa é multiplicar as matrizes <em>A</em> e
<em>B</em>. Por meio da decomposição de domínio, podemos replicar essa
tarefa em cada núcleo. Conforme mostrado na <a href="chap13.html#figure-matrix_decomposition">Figura 13.4</a>,
cada núcleo calcula apenas uma parte de <em>C</em>. Por exemplo, se
<em>A</em> e <em>B</em> forem 4 × 4, podemos pedir a um núcleo que calcule o produto das duas primeiras
linhas de <em>A</em> com todas as quatro colunas de <em>B</em> para
gerar as duas primeiras linhas de <em>C</em>. O segundo núcleo calcula
as duas linhas restantes de <em>C</em>. Ambos os núcleos podem acessar as
matrizes <em>A</em> e <em>B</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tarefas_e_threads">13.3.3. Tarefas e threads</h4>
<div class="paragraph">
<p>É responsabilidade do programador dividir sua solução em
uma série de tarefas e subtarefas que serão executadas em um ou mais núcleos de um
processador. Nas seções anteriores, descrevemos programas concorrentes como se
tarefas específicas pudessem ser atribuídas a núcleos específicos, mas o Java não
fornece uma maneira direta de fazer isso.</p>
</div>
<div class="paragraph">
<p>Em vez disso, um programador Java deve agrupar um conjunto de tarefas e
subtarefas em uma <em>thread</em>. Uma thread é muito parecido com um programa
sequencial. De fato, todos os programas sequenciais são compostos de uma única thread.
Uma thread é um segmento de execução de código que percorre suas instruções passo a passo. Cada thread pode ser executado de forma independente. Se você tiver um processador de núcleo único
apenas uma thread pode ser executada por vez, e todas as threads se revezarão. Se você tiver um processador com vários núcleos, tantas threads quantos forem os núcleos
núcleos podem ser executados ao mesmo tempo. Não é possível escolher em qual núcleo uma
determinada thread será executada. Na maioria dos casos, você não conseguirá nem mesmo
saber qual núcleo uma determinada thread está usando.</p>
</div>
<div class="paragraph">
<p>Ele tem o cuidado de empacotar o conjunto certo de tarefas em uma única thread
de execução. Lembre-se dos exemplos anteriores de programação concorrente neste capítulo.</p>
</div>
<div class="paragraph">
<p>Considere a possibilidade de dividir as tarefas em <a href="chap13.html#videoGameTasksExample">Exemplo 13.1</a> em
duas threads. As tarefas B e C podem ser agrupadas na thread 1, e a tarefa D
pode ser empacotada na thread 2.Essa divisão é mostrada em
<a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>(a).</p>
</div>
<div class="paragraph">
<p>As tarefas para avaliar diferentes subexpressões em <a href="chap13.html#mathExpressionTasksExample">Exemplo 13.2</a> também podem ser divididas em duas threads, conforme mostrado em <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a> (b). Em muitos problemas, há várias maneiras razoáveis de dividir um conjunto de subtarefas em threads.</p>
</div>
<div id="figure-tasks_in_threads" class="imageblock">
<div class="content">
<img src="chapters/13-concurrency/images/task-thread-packaging.svg" alt="task thread packaging" width="100%">
</div>
<div class="title">Figura 13.5 (a)&nbsp;Tarefas em um videogame mostradas agrupadas em duas threads. (b) Tarefas para avaliar uma expressão matemática mostrada empacotada em duas threads. Cada thread pode ou não ser executado no mesmo núcleo que o outro.</div>
</div>
<div class="paragraph">
<p>Observe que essas figuras são exatamente iguais às figuras anteriores, exceto
que as tarefas são agrupadas como threads em vez de núcleos. Esse agrupamento
corresponde melhor à realidade, pois podemos controlar como as tarefas são agrupadas
em threads, mas não como elas são atribuídas aos núcleos.</p>
</div>
<div class="paragraph">
<p>Em ambos os exemplos, temos duas threads. É possível que alguma outra thread tenha iniciado a execução dessas threads. Todo programa Java, simultâneo ou
sequencial, começa com uma thread. Vamos nos referir a essa thread como a thread
<em>main</em>, pois ela contém o método <code>main()</code>.</p>
</div>
<div class="paragraph">
<p><a href="chap13.html#arraySummationPreviewExample">Exemplo 13.3</a> e <a href="chap13.html#matrixMultiplicationPreviewExample">Exemplo 13.4</a> usam várias tarefas idênticas,
mas essas tarefas operam em dados diferentes. Em <a href="chap13.html#arraySummationPreviewExample">Exemplo 13.3</a>,
as duas tarefas podem ser atribuídas a duas threads que
operam em diferentes partes da matriz de entrada. A tarefa de somar
os resultados das duas threads pode ser uma thread separada ou uma
subtarefa incluída em uma das outras threads. Em
<a href="chap13.html#matrixMultiplicationPreviewExample">Exemplo 13.4</a>, as duas tarefas podem
novamente ser atribuídas a duas threads distintas que operam em diferentes
partes diferentes da matriz de entrada <em>A</em> para gerar as partes correspondentes
partes correspondentes da matriz de saída <em>C</em>.</p>
</div>
<div class="paragraph">
<p>Pode haver muitas maneiras de empacotar tarefas em threads. Também pode haver
muitas maneiras de decompor os dados em pedaços menores. As melhores maneiras de
executar essas subdivisões de tarefas ou dados dependem do problema em questão e
da arquitetura do processador em que o programa será executado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arquitecturas_de_memória_e_concorrência">13.3.4. Arquitecturas de memória e concorrência</h4>
<div class="paragraph">
<p>Os dois paradigmas mais importantes da programação concorrente são a passagem de mensagens e os sistemas de memória compartilhada. Cada paradigma lida com a comunicação entre as várias unidades de código executadas em paralelo de uma maneira diferente. Os sistemas de passagem de mensagens, como o MPI (Message Passing Interface), abordam esse problema enviando mensagens entre unidades de código independentes, chamadas de processos. Um processo que está executando uma tarefa pode ter de esperar até receber uma mensagem de outro processo para saber como proceder. As mensagens podem ser enviadas de um único processo para outro ou transmitidas para vários. Os sistemas de passagem de mensagens são especialmente úteis quando os processadores que executam o trabalho não compartilham memória.</p>
</div>
<div class="paragraph">
<p>Por outro lado, o sistema interno de concorrência em Java usa o paradigma de memória compartilhada.
compartilhada. Em Java, um programador
pode criar várias threads que compartilham o mesmo espaço de memória. Cada
thread é um objeto que pode executar um trabalho. Descrevemos as threads como uma como uma forma de empacotar um grupo de tarefas, e os processos são outra forma. As pessoas
usam o termo <em>processos</em> para descrever unidades de código em execução com
memória separada e <em>threads</em> para descrever unidades de código em execução
com memória compartilhada.</p>
</div>
<div class="paragraph">
<p>Quando você aprendeu a programar pela primeira vez, um dos maiores desafios foi provavelmente aprender a resolver um problema passo a passo. Cada linha do programa tinha de ser executada uma de cada vez, de forma lógica e
deterministica. Os seres humanos não pensam naturalmente dessa forma. Temos a tendência de pular de uma coisa para outra, fazendo inferências e suposições,
pensando em duas coisas não relacionadas ao mesmo tempo, e assim por diante. Como você sabe
agora, só é possível escrever e depurar programas por causa da maneira metódica como eles funcionam.</p>
</div>
<div class="paragraph">
<p>Você pode imaginar a execução de um programa como uma seta que aponta para uma linha de código, depois a próxima, depois a próxima e assim por diante. Podemos pensar no movimento dessa seta como a thread de execução do programa.
O código faz o trabalho real, mas a seta mantém o controle de onde a
execução do programa está no momento. O código pode mover a seta
para frente, pode fazer aritmética básica, pode decidir entre escolhas com instruções pode fazer coisas repetidamente com loops, pode pular para um método e depois voltar. Uma única thread de execução pode fazer todas essas coisas, mas sua seta não pode estar em dois lugares ao mesmo tempo. Ela não pode
dividir dois números em uma parte do programa e avaliar uma declaração <code>if</code> em outra. No entanto, há uma maneira de dividir essa thread
de execução de modo que duas ou mais threads estejam executando partes diferentes
do programa, e a próxima seção mostrará como isso é feito em
Java.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sintaxe_threads_em_java">13.4. Sintaxe: Threads em Java</h3>
<div class="sect3">
<h4 id="_a_classe_thread">13.4.1. A classe <code>Thread</code></h4>
<div class="paragraph">
<p>O Java, como muitas linguagens de programação, inclui os recursos necessários para para empacotar tarefas e subtarefas em threads. A classe <code>Thread</code> e suas subclasses fornecem as ferramentas para criar e gerenciar threads. Por exemplo, a definição de classe a seguir permite que objetos do tipo
<code>ThreadedTask</code> sejam criados. Esse objeto pode ser executado como uma thread separada.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadedTask</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="c1">// Adicionar construtor e corpo da classe</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O construtor é escrito como qualquer outro construtor, mas há um método especial
<code>run()</code> em <code>Thread</code> que pode ser substituído por qualquer uma das
suas subclasses. Esse método é o ponto de partida para a thread de execução associada a uma instância da classe. A maioria dos aplicativos Java
começa com uma única thread principal que é iniciado em um método <code>main()</code>. As threads adicionais devem começar em algum lugar, e esse lugar é o método
 <code>run()</code>. Um aplicativo Java continuará a ser executado enquanto houver pelo menos uma thread ativa. O exemplo a seguir mostra duas threads,
cada uma avaliando uma subexpressão separada, como em <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>(b).</p>
</div>
<div id="threadSamplesExample" class="exampleblock">
<div class="title">Exemplo 13.5 Exemplos de Threads</div>
<div class="content">
<div class="paragraph">
<p>Vamos criar as classes <code>Thread1</code> e <code>Thread2</code>. As threads de execução criadas por
instâncias destas classes calculam, respetivamente, as duas subexpressões da
<a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>(b) e guardam os valores calculados.</p>
</div>
<div id="Thread1Program" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread1</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="no">K</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
 
    <span class="kd">public</span> <span class="nf">Thread1</span><span class="o">(</span><span class="kt">double</span> <span class="no">K</span><span class="o">,</span> <span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">K</span> <span class="o">=</span> <span class="no">K</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="no">K</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div id="Thread2Program" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread2</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
    
    <span class="kd">public</span>  <span class="nf">Thread2</span><span class="o">(</span><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">exp</span><span class="o">(-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O método <code>run()</code> em cada thread acima calcula uma subexpressão e salva seu
valor. Mostramos como essas threads podem ser executados para resolver o problema
da expressão matemática em <a href="chap13.html#mathExpressionThreadsExample">Exemplo 13.6</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_criando_um_objeto_thread">13.4.2. Criando um objeto thread</h4>
<div class="paragraph">
<p>Criar um objeto a partir de uma subclasse <code>Thread</code> é o mesmo que criar
qualquer outro objeto em Java. Por exemplo, podemos instanciar a classe <code>Thread1</code>
acima para criar um objeto chamado <code>thread1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Thread1</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread1</span><span class="o">(</span><span class="mf">15.1</span><span class="o">,</span> <span class="mf">2.8</span><span class="o">,</span> <span class="mf">7.53</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O uso da palavra-chave <code>new</code> para invocar o construtor cria um objeto <code>Thread1</code>,
mas não começa a executá-lo como uma nova thread. Como em todas as
outras classes, o construtor inicializa os valores dentro do novo objeto
objeto. Uma subclasse de <code>Thread</code> pode ter muitos construtores diferentes com
qualquer parâmetros que seu projetista considere apropriados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_iniciando_uma_thread">13.4.3. Iniciando uma thread</h4>
<div class="paragraph">
<p>Para iniciar a execução do objeto thread, seu método <code>start()</code> deve ser
chamado. Por exemplo, o objeto <code>thread1</code> criado acima pode ser iniciado
da seguinte forma.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez iniciado, uma thread é executada de forma independente.  A chamada do método <code>start()</code>
chama automaticamente o método <code>run()</code> do objeto nos bastidores.
Quando uma thread precisa compartilhar dados com outra thread, ela
pode ter que esperar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aguardando_por_uma_thread">13.4.4. Aguardando por uma thread</h4>
<div class="paragraph">
<p>Muitas vezes, alguma thread, principal ou não, precisa esperar por outra thread
antes de prosseguir com sua execução. O método <code>join()</code> é usado para esperar
que uma thread termine a execução. Por exemplo, qualquer thread que executar o
código a seguir aguardará a conclusão da <code>thread1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A chamada <code>join()</code> é uma chamada <em>bloqueante</em>, o que significa que o código que chama
esse método aguardará até que ele retorne. Como ele pode lançar uma
<code>InterruptedException</code> verificada enquanto o código estiver aguardando, o método <code>join()</code>
é geralmente usado em um bloco <code>try</code>-<code>catch</code>. Podemos adicionar um bloco <code>try</code>-<code>catch</code>
ao exemplo <code>thread1</code> para que possamos nos recuperar de
sermos interrompidos enquanto aguardamos a conclusão do <code>thread1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="k">try</span> <span class="o">{</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Aguardando pela thread 1..."</span><span class="o">);</span>
	<span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 finalizada!"</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread 1 não acabou!"</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe que a <code>InterruptedException</code> é lançada porque a thread principal
foi interrompida enquanto aguardava a conclusão da <code>thread1</code>. Se a chamada <code>join()</code>
retornar, então <code>thread1</code> deve ter terminado e informaremos o usuário.
Se uma <code>InterruptedException</code> for lançada, alguma thread externa deve ter
interrompido a thread principal, forçando-a a parar de esperar pela <code>thread1</code>.</p>
</div>
<div class="paragraph">
<p>In earlier versions of Java, there was a <code>stop()</code> method which would
stop an executing thread. Although this method still exists, it’s been
deprecated and shouldn’t be used because it can make a program behave
in an unexpected way.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#threadMethodsExercise">Exercício 13.1</a></p>
</div>
</div>
</div>
<div id="mathExpressionThreadsExample" class="exampleblock">
<div class="title">Exemplo 13.6 Cálculos matemáticos com threads</div>
<div class="content">
<div class="paragraph">
<p>Agora que temos a sintaxe para iniciar threads e esperar que eles terminem, podemos
usar as threads definidos em <a href="chap13.html#threadSamplesExample">Exemplo 13.5</a> com uma thread principal
para criar nosso primeiro programa concorrente completo.  A thread principal na
classe <code>MathExpression</code> cria e inicia as threads de trabalho <code>thread1</code> e <code>thread2</code>
e aguarda sua conclusão. Quando as duas threads concluem sua execução, podemos
solicitar a cada uma delas o valor calculado. A thread principal imprime o
produto desses valores, que é o resultado da expressão que queremos avaliar.</p>
</div>
<div id="MathExpressionProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MathExpression</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">120</span><span class="o">,</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">Thread1</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread1</span><span class="o">(</span><span class="no">K</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
        <span class="nc">Thread2</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// Start thread1</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// Start thread2</span>
        <span class="k">try</span> <span class="o">{</span> <span class="c1">// Wait for both threads to complete</span>
            <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value of expression: "</span> <span class="o">+</span>
                    <span class="n">thread1</span><span class="o">.</span><span class="na">getValue</span><span class="o">()*</span><span class="n">thread2</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A thread didn't finish!"</span><span class="o">);</span>
        <span class="o">}</span>        
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Queremos deixar absolutamente claro quando os threads são criados, começam
a execução e terminam. Esses detalhes são cruciais para os pontos mais finos da
programação Java simultânea. Na <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>, parece que a execução da avaliação da expressão matemática
começa com a Thread 1, que gera a Thread 2. Embora essa figura
explique bem os conceitos básicos da decomposição de tarefas, os detalhes são mais confusos para o código Java real.</p>
</div>
<div class="paragraph">
<p>No código acima, a execução começa com o método <code>main()</code> em
<code>MathExpression</code>. Ele cria os objetos <code>Thread1</code> e <code>Thread2</code> e aguarda
que eles terminem. Em seguida, ele lê os valores dos objetos depois que
eles pararam de ser executados. Poderíamos ter colocado o método <code>main()</code> na classe <code>Thread1</code>, omitindo totalmente a classe <code>MathExpression</code>. Desta forma isso faria com que a execução correspondesse mais de perto à <a href="chap13.html#figure-tasks_in_threads">Figura 13.5</a>
mais próxima, mas tornaria as duas subclasses <code>Thread</code> menos
simétricas: a thread principal e a <code>thread1</code> executariam independentemente o código dentro da <code>Thread1</code>.
executariam independentemente o código dentro da classe <code>Thread1</code>, enquanto somente <code>thread2</code> executaria
executaria código dentro da classe <code>Thread2</code>.</p>
</div>
<div id="figure-thread_execution" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/thread-lifecycle.svg" alt="thread lifecycle" width="75%">
</div>
<div class="title">Figura 13.6 Criando, iniciando, e mesclando as threads em <code>MathExpression</code>, <code>Thread1</code>, and <code>Thread2</code>.</div>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-thread_execution">Figura 13.6</a> mostra a execução de <code>thread1</code> e
<code>thread2</code> e a thread principal. Observe que a JVM cria e inicia implicitamente
o thread principal, que cria e inicia explicitamente a <code>thread1</code> e a <code>thread2</code>.
Mesmo depois que as threads associados a <code>thread1</code> e <code>thread2</code> pararem de ser executados,
os objetos associados a eles continuam a existir. Seus métodos e campos ainda podem ser acessados.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_a_interface_runnable">13.4.5. A interface <code>Runnable</code></h4>
<div class="paragraph">
<p>Embora seja possível criar threads em Java herdando diretamente da classe
<code>Thread</code> diretamente, a API Java permite que o programador use uma
interface em vez disso.</p>
</div>
<div class="paragraph">
<p>Como exemplo, a classe <code>Summer</code> pega uma matriz de valores <code>int</code> e os soma dentro
de um determinado intervalo. Se várias instâncias dessa classe
forem executadas como threads separadas, cada uma delas poderá somar diferentes partes de
uma matriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Summer</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Summer</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sum</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa classe é muito semelhante a uma classe que herda de <code>Thread</code>. Imagine
por um momento que o código que segue <code>Summer</code> é <code>extends Thread</code>
em vez de <code>implements Runnable</code>. A principal coisa que uma classe derivada de
<code>Thread</code> precisa é de um método <code>run()</code> sobrescrito. Como somente o método <code>run()</code>
é importante, os projetistas do Java forneceram uma maneira de criar uma
thread usando a interface <code>Runnable</code>. Para implementar essa interface, é necessário apenas
um método <code>public void run()</code>.</p>
</div>
<div class="paragraph">
<p>Ao criar uma nova thread, há algumas diferenças de sintaxe entre os dois estilos. A maneira conhecida de criar e executar um thread a partir de uma subclasse <code>Thread</code> é a seguinte.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Summer</span> <span class="n">summer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Summer</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
<span class="n">summer</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Como o <code>Summer</code> não herda de <code>Thread</code>, ele não tem um método <code>start()</code>, e esse código não será compilado. Quando uma classe apenas implementa <code>Runnable</code>, ainda é necessário criar um objeto <code>Thread</code> e chamar seu método <code>start()</code>. Portanto, é necessária uma etapa extra.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">Summer</span> <span class="n">summer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Summer</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">lower</span><span class="o">,</span> <span class="n">upper</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">summer</span><span class="o">);</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa forma alternativa de implementar a interface <code>Runnable</code> parece mais incômoda do que herdar diretamente da <code>Thread</code>, já que é necessário
instanciar um objeto <code>Thread</code> separado. Entretanto, a maioria dos desenvolvedores prefere projetar classes que implementem <code>Runnable</code> em vez de herdar de
<code>Thread</code>. Por quê? O Java só permite herança única. Se sua classe
implementar <code>Runnable</code>, ela estará livre para herdar de outra super classe
com os recursos que você desejar.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#extendingThreadExercise">Exercício 13.2</a></p>
</div>
</div>
</div>
<div id="arrayOfThreadsExample" class="exampleblock">
<div class="title">Exemplo 13.7 Conjunto de threads</div>
<div class="content">
<div class="paragraph">
<p>Na decomposição de domínios, muitas vezes precisamos criar várias threads, todas
a partir da mesma classe. Como exemplo, considere a seguinte declaração de thread.</p>
</div>
<div id="NumberedThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberedThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">NumberedThread</span><span class="o">(</span><span class="kt">int</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">input</span><span class="o">;</span> <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, suponha que desejemos criar 10 objetos de thread do tipo
<code>NumberedThread</code>, então iniciá-los e por fim esperar que sejam concluídos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">NumberedThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberedThread</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberedThread</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="o">}</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="o">}</span>
<span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A thread didn't finish!"</span><span class="o">);</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Primeiro, declaramos uma matriz para manter referências aos objetos <code>NumberedThread</code>. Como qualquer outro tipo, podemos criar uma matriz para armazenar objetos que
herdam de <code>Thread</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A primeira linha do loop <code>for</code> instancia um novo objeto <code>NumberedThread</code>, invocando o construtor que armazena a
iteração atual do loop no campo <code>value</code>. A referência a
cada objeto <code>NumberedThread</code> é armazenada na matriz. Lembre-se de que o construtor
 <strong>não</strong> inicia a execução de uma nova thread.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A segunda linha do loop <code>for</code> faz isso.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Também estamos interessados em saber quando as threads param. A chamada do método <code>join()</code>
força a thread principal a aguardar a conclusão de cada thread.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Todo o segundo loop <code>for</code> está aninhado dentro de um bloco <code>try</code>. Se a thread principal for interrompida enquanto estiver aguardando a conclusão de qualquer uma das threads terminar, uma <code>InterruptedException</code> será capturada. Como antes, avisamos o usuário
que uma thread não foi concluída. Para código com qualidade de produção, o bloco
bloco <code>catch</code> deve tratar a exceção de forma que a thread possa se recuperar e fazer um trabalho útil, mesmo que não tenha obtido o resultado esperado.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exemplos_concorrência_e_aceleração">13.5. Exemplos: Concorrência e aceleração</h3>
<div class="paragraph">
<p>A aceleração é uma das maiores motivações para escrever programas
concorrentes. Para entender o aumento de velocidade, vamos supor que temos um problema para
resolver. Escrevemos dois programas para resolver esse problema, um que é
sequencial e outro que é concorrente e, portanto, capaz de explorar
vários núcleos. Seja <em>t</em><sub><em>s</em></sub> o tempo médio de execução do
o programa sequencial e <em>t</em><sub><em>c</em></sub> o tempo médio de execução do programa concorrente. Para que a comparação seja
significativa, suponha que ambos os programas sejam executados no mesmo computador.
O aumento de velocidade obtido com a programação concorrente é definido como <em>t</em><sub><em>s</em></sub>/<em>t</em><sub><em>c</em></sub>.</p>
</div>
<div class="paragraph">
<p>A aceleração mede quanto tempo leva para o programa concorrente ser executado em relação ao programa sequencial. Idealmente, esperamos que
<em>t</em><sub><em>c</em></sub> &lt; <em>t</em><sub><em>s</em></sub>, tornando a aceleração maior que 1. No entanto,
simplesmente escrever um programa concorrente não garante que ele seja mais rápido
do que a versão sequencial.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#speedupExercise">Exercício 13.6</a><br>
<a href="chap13.html#AmdahlLawExercise">Exercício 13.8</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Para determinar o aumento de velocidade, precisamos medir <em>t</em><sub><em>s</em></sub> e <em>t</em><sub><em>c</em></sub>. O
tempo em um programa Java pode ser facilmente medido com
os dois métodos estáticos a seguir na classe <code>System</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">currentTimeMillis</span><span class="o">()</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">nanoTime</span><span class="o">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro desses métodos retorna a hora atual em milissegundos (ms).
Um <em>millisecond</em> equivale a 0,001 segundos. Esse método fornece a diferença
entre a hora atual no relógio de seu computador e a meia-noite de
1º de janeiro de 1970, horário universal coordenado (UTC). Esse ponto no tempo é
usado para muitos recursos de tempo em muitas plataformas de computador e é chamado de <em>epoch Unix</em>. O outro método retorna a hora atual em
nanossegundos (ns). Um <em>nanossegundo</em> equivale a 0,000000001 ou 10<sup>-9</sup> segundos.
Esse método também fornece a diferença entre a hora atual e uma hora fixa, que depende do sistema e não necessariamente do <em>epoch</em>.
O método <code>System.nanoTime()</code> pode ser usado quando você quiser uma precisão de tempo
mais fina do que milissegundos; entretanto, o nível de precisão que ele retorna é
novamente dependente do sistema. O próximo exemplo mostra como usar esses métodos
para medir o tempo de execução.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 13.8 Medindo o tempo de execução</div>
<div class="content">
<div class="paragraph">
<p>Suponha que desejemos medir o tempo de execução de um trecho de código Java. Por conveniência, podemos supor que esse código esteja contido no método <code>work()</code>. O trecho de código a seguir mede o tempo de execução de
<code>work()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="n">work</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tempo decorrido: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A saída fornecerá o tempo de execução de <code>work()</code> medido em
milissegundos. Para obter o tempo de execução em nanossegundos, use o método
<code>System.nanoTime()</code> em vez de <code>System.currentTimeMillis()</code>.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#executionVariationExercise">Exercício 13.15</a><br>
<a href="chap13.html#threadOverheadExercise">Exercício 13.16</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Agora que temos as ferramentas para medir o tempo de execução, podemos medir o
aumento de velocidade. Os próximos exemplos mostram o aumento de velocidade (ou a falta dele) que podemos
podemos obter usando uma solução simultânea para alguns problemas simples.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 13.9 Acelerando o cálculo matemático</div>
<div class="content">
<div class="paragraph">
<p>Lembre-se do programa concorrente em <a href="chap13.html#mathExpressionThreadsExample">Exemplo 13.6</a> para avaliar uma expressão matemática simples. Esse programa
usa duas threads. Executamos esse programa multithread em um computador iMac
com um Intel Core 2 Duo rodando a 2,16 Ghz. O tempo de execução
O tempo de execução foi medido em 1.660.000 nanossegundos. Também escrevemos um programa
programa sequencial simples para avaliar a mesma expressão. Foram necessários 4.100
nanossegundos para executar esse programa no mesmo computador. Ao inserir
esses valores para <em>t</em><sub><em>c</em></sub> e <em>t</em><sub><em>s</em></sub>, podemos encontrar
a aceleração.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/speedup.svg" alt="speedup" width="45%">
</div>
</div>
<div class="paragraph">
<p>Essa aceleração é muito menor que 1. Embora esse resultado possa ser surpreendente,
o programa concorrente com duas threads é executado mais lentamente do que o programa
sequencial. Nesse exemplo, o custo de criar, executar e
processar as threads supera os benefícios do cálculo simultâneo em dois
núcleos.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#speedupLimitationsExercise">Exercício 13.7</a></p>
</div>
</div>
</div>
<div id="arraySummationExample" class="exampleblock">
<div class="title">Exemplo 13.10 Somatório de matrizes</div>
<div class="content">
<div class="paragraph">
<p>In <a href="chap13.html#arraySummationPreviewExample">Exemplo 13.3</a>, we introduced the
problem of applying a function to every value in an array and then
summing the results. Let’s say that we want to apply the sine function
to each value. To solve this problem concurrently, we partition the
array evenly among a number of threads, using the domain decomposition
strategy. Each thread finds the sum of the sines of the values in its
part of the array. One factor that determines whether or not we achieve
speedup is the complexity of the function, in this case sine, that we
apply. Although we may achieve speedup with sine, a simpler function
such as doubling the value might not create enough work to justify the
overhead of using threads.</p>
</div>
<div class="paragraph">
<p>We create class <code>SumThread</code> whose <code>run()</code> method sums the sines of those
elements of the array in its assigned partition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SumThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SIZE</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREADS</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">SumThread</span><span class="o">(</span><span class="kt">double</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
		<span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>     
    <span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, we set up all the fields that the class will need.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Note that every <code>SumThread</code> object will have its own reference to the array of data.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We fix the
array size at 1,000,000 and the number of threads at 8, but these values
could easily be changed or read as input instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In its constructor, a <code>SumThread</code> takes a reference to the array of data
and the lower and upper bounds of its partition. Like most
ranges we discuss, the lower bound is inclusive though the upper bound
is exclusive.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sin</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getSum</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sum</span><span class="o">;</span> <span class="o">}</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In the <code>for</code> loop of the <code>run()</code> method, the <code>SumThread</code> finds the sine
of each number in its array partition and adds that value to its running
sum.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>getSum()</code> method is an accessor that allows the running sum to
be retrieved.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kt">double</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="no">SIZE</span><span class="o">];</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span>  
        <span class="nc">SumThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumThread</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="no">THREADS</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="no">THREADS</span><span class="o">;</span>          
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="n">quotient</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="o">)</span>
                <span class="n">work</span><span class="o">++;</span>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumThread</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">work</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">work</span><span class="o">;</span>
        <span class="o">}</span>   </code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>main()</code> method begins by instantiating the array.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>It fills it with random values.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then, each thread is created by passing in a reference to the array and
lower and upper bounds that mark the thread’s partition of the array. If the
process using the array length and the number of threads to determine
upper and lower bounds doesn’t make sense, refer to
<a href="chap6.html#_concurrency_arrays">Section 6.11</a> which describes the fair division of work
to threads. If the length of the array is not divisible by the number of
threads, simple division isn’t enough.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>After each thread is created, its <code>start()</code> method is called.</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java">        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">try</span> <span class="o">{</span> 
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getSum</span><span class="o">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum: "</span> <span class="o">+</span> <span class="n">threads</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getSum</span><span class="o">());</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="o">}</span>
    <span class="o">}</span>   
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Once the threads have started working, the main thread creates its own
running total.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>It iterates through each thread waiting for it to
complete.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>When each thread is done, its value is added to
the running total.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finally, the sum is printed out.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If the main thread is interrupted while waiting for a
thread to complete, the stack trace is printed.</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#parallelAudioProcessingExercise">Exercício 13.12</a><br>
<a href="chap13.html#arraySummingSpeedupExercise">Exercício 13.19</a><br>
<a href="chap13.html#treeSummationExercise">Exercício 13.20</a></p>
</div>
</div>
</div>
<div id="matrixMultiplicationExample" class="exampleblock">
<div class="title">Exemplo 13.11 Matrix multiplication</div>
<div class="content">
<div class="paragraph">
<p>In <a href="chap13.html#matrixMultiplicationPreviewExample">Exemplo 13.4</a>, we discussed the
importance of matrix operations in many applications. Now that we know
the necessary Java syntax, we can write a concurrent program to multiply
two square matrices <em>A</em> and <em>B</em> and compute the
resultant matrix <em>C</em>. If these matrices have <em>n</em>
rows and <em>n</em> columns, the value at the <em>i</em><sup>th</sup>
row and <em>j</em><sup>th</sup> column of <em>C</em> is</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/matrixValue.svg" alt="matrixValue" width="55%">
</div>
</div>
<div class="paragraph">
<p>In Java, it’s natural for us to store matrices as 2-dimensional arrays.
To do this multiplication sequentially, the simplest approach uses three
nested <code>for</code> loops. The code below is a direct translation of the
mathematical notation, but we do have to be careful about bookkeeping.
Note that mathematical notation often uses uppercase letters to
represent matrices though the Java convention is to start all variable
names with lowercase letters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
            <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step in making a concurrent solution to this problem is to
create a <code>Thread</code> subclass which will do some part of the matrix
multiplication. Below is the <code>MatrixThread</code> class which will compute a
number of rows in the answer matrix <code>c</code>.</p>
</div>
<div id="MatrixThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MatrixThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">c</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>  
    
    <span class="kd">public</span> <span class="nf">MatrixThread</span><span class="o">(</span><span class="kt">double</span><span class="o">[][]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">b</span><span class="o">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>      
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>              
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The constructor for <code>MatrixThread</code> stores references to the arrays
corresponding to matrices <em>A</em>, <em>B</em>, and
<em>C</em> as well as lower and upper bounds on the rows of
<em>C</em> to compute.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The body of the <code>run()</code> method is identical
to the sequential solution except that its outermost loop runs only from
<code>lower</code> to <code>upper</code> instead of through all the rows of the result. It’s
critical that each thread is assigned a set of rows that does not
overlap with the rows another thread has. Not only would having multiple
threads compute the same row be inefficient, it would very likely lead
to an incorrect result, as we’ll see in
<a href="chap14.html">Chapter 14</a>.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The following client code uses an array of <code>MatrixThread</code> objects to
perform a matrix multiplication. We assume that an <code>int</code> constant named
<code>THREADS</code> has been defined which gives the number of threads we want to
create.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="nc">MatrixThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MatrixThread</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="no">THREADS</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span> <span class="o">%</span> <span class="no">THREADS</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">quotient</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="o">)</span>
        <span class="n">rows</span><span class="o">++;</span>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MatrixThread</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">rows</span><span class="o">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">rows</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
<span class="o">}</span>
<span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We loop through the array, creating a <code>MatrixThread</code> object for each
location. As in the previous example, we use the approach described in
<a href="chap6.html#_concurrency_arrays">Section 6.11</a> to allocate rows to each thread fairly.
Each new <code>MatrixThread</code> object is given a reference to each of the three
matrices as well as an inclusive starting and an exclusive ending row.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>After the <code>MatrixThread</code> objects are created, we start them running with
the next line of code.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Next, there’s a familiar <code>for</code> loop with the <code>join()</code> calls that force
the main thread to wait for the other threads to finish.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Presumably,
code following this snippet will print the values of the result matrix
or use it for other calculations. If we didn’t use the <code>join()</code>
calls to be sure the threads have finished, we might print out a result
matrix that’s only been partially filled in.</p>
</div>
<div class="paragraph">
<p>We completed the code for threaded matrix multiplication and executed it
on an iMac computer with an Intel Core 2 Duo running at 2.16 Ghz. The program
was executed for matrices of different sizes (<em>n</em> × <em>n</em>).
For each size, the sequential and concurrent execution times in seconds
and the corresponding speedup are listed in the following table.</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Size (<em>n</em>)</th>
<th class="tableblock halign-left valign-top"><em>t</em><sub><em>s</em></sub> (s)</th>
<th class="tableblock halign-left valign-top"><em>t</em><sub><em>c</em></sub> (s)</th>
<th class="tableblock halign-left valign-top">Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.013</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.75</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.39</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.45<sup>*</sup></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Only with 1,000 × 1,000 matrices did we see improved
performance when using two threads. In that case, we achieved a speedup
of 1.45, marked with an asterisk. In the other two cases, performance
became worse.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#parallelPiApproximationExercise">Exercício 13.14</a><br>
<a href="chap13.html#matrixSpeedupExercise">Exercício 13.17</a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_concepts_thread_scheduling">13.6. Concepts: Thread scheduling</h3>
<div class="paragraph">
<p>Now that we’ve seen how multiple threads can be used together, a
number of questions arise: Who decides when
these threads run? How is processor time shared between threads? Can we
make any assumptions about the order in which the threads run? Can
we affect this order?</p>
</div>
<div class="paragraph">
<p>These questions focus on thread scheduling. Because different concurrent
systems handle scheduling differently, we’ll only describe scheduling
in Java. Although sequential programming is all about precise control
over what happens <strong>next</strong>, concurrency takes much of this control away
from the programmer. When threads are scheduled and which processor they
run on is handled by a combination of the JVM and the OS. With normal
JVMs, there’s no explicit way to access the scheduling and alter it to
your liking.</p>
</div>
<div class="paragraph">
<p>Of course, there are a number of implicit ways a programmer can affect
scheduling. In Java, as in several other languages and programming
systems, threads have <em>priorities</em>. Higher priority threads run more
often than lower priority threads. Some threads are performing
mission-critical operations which must be carried out as quickly as
possible, and some threads are just doing periodic tasks in the
background. A programmer can set thread priorities accordingly.</p>
</div>
<div class="paragraph">
<p>Setting priorities gives only a very general way of controlling which
thread will run. The threads themselves might have more specific
information about when they will and won’t need processor time. A
thread may need to wait for a specific event and won’t need to run
until then. Java allows threads to interact with the scheduler through
<code>Thread.sleep()</code> and <code>Thread.yield()</code>, which we’ll discuss in
<a href="chap13.html#_syntax_thread_states">Section 13.7</a>, and through the <code>wait()</code>, method which
we’ll discuss in <a href="chap14.html">Chapter 14</a>.</p>
</div>
<div class="sect3">
<h4 id="_nondeterminism">13.6.1. Nondeterminism</h4>
<div class="paragraph">
<p>In Java, the mapping of a thread inside the JVM to a thread in the OS
varies. Some implementations give each Java thread an OS thread, some
put all Java threads on a single OS thread (with the side effect of
preventing parallel execution), and some allow for the possibility of changing
which OS thread a Java thread uses. Thus, the performance and, in some
cases, the correctness of your program might vary, depending on which
system you’re running. This is, yet again, one of those times when Java
is platform independent…​but not entirely.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the situation is even more complicated. Making threads
part of your program means that the same program could run differently
on the <strong>same</strong> system. The JVM and the OS have to cooperate to schedule
threads, and both programs are complex mountains of code which try to
balance many factors. If you create three threads, there’s no guarantee
that the first will run first, the second second, and the third third,
even if it happens that way the first 10 times you run the program.
<a href="chap13.html#executionOrderExercise">Exercício 13.18</a> shows that the pattern of thread
execution can vary a lot.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#executionOrderExercise">Exercício 13.18</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>In all the programs before this chapter, the same sequence of input
would always produce the same sequence of output. Perhaps the biggest
hurdle created by this nondeterminism is that programmers must shift
their paradigm considerably. The processor can switch between executions
of threads at any time, even in the middle of operations. Every possible
interleaving of thread execution could crop up at some point. Unless you
can be sure that your program behaves properly for all of them, you might
never be able to debug your code completely. What’s so insidious about
nondeterministic bugs is that they can occur rarely and be almost
impossible to reproduce. In this chapter, we’ve introduced how to create and
run threads, but making these threads interact properly is a major
problem we tackle in subsequent chapters.</p>
</div>
<div class="paragraph">
<p>After those dire words of warning, we’d like to remind you that
nondeterminism is not in itself a bad thing. Many threaded applications
with a lot of input and output, such as server applications, necessarily
exist in a nondeterministic world. For these programs, many different
sequences of thread execution may be perfectly valid. Each individual
program may have a different definition of correctness. For example, if
a stock market server receives two requests to buy the last share of a
particular stock at almost the same time from two threads corresponding
to two different clients, it might be correct for either one of them to
get that last share. However, it would never be correct for <strong>both</strong> of
them to get it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_polling">13.6.2. Polling</h4>
<div class="paragraph">
<p>So far the only mechanism we’ve introduced for coordinating different
threads is using the <code>join()</code> method to wait for a thread to end.
Another technique is <em>polling</em>, or <em>busy waiting</em>. The idea is to keep
checking the state of one thread until it changes.</p>
</div>
<div class="paragraph">
<p>There are a number of problems with this approach. The first is that it
wastes CPU cycles. Those cycles spent by the waiting thread continually
checking could have been used productively by some other thread in the
system. The second problem is that we have to be certain that the state
of the thread we’re waiting for won’t change back to the original state
or to some other state. Because of the unpredictability of scheduling,
there’s no guarantee that the waiting thread will read the state of the
other thread when it has the correct value.</p>
</div>
<div class="paragraph">
<p>We bring up polling partly because it has a historical importance to
parallel programming, partly because it can be useful in solving some
problems in this chapter, and partly because we want you to understand
the reasons why we need better techniques for thread communication.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#pollingArraySumExercise">Exercício 13.11</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_thread_states">13.7. Syntax: Thread states</h3>
<div class="paragraph">
<p>A widely used Java tool for manipulating scheduling is the
<code>Thread.sleep()</code> method. This method can be called any time you want a
thread to do nothing for a set period of time. Until the sleep timer
expires, the thread will not be scheduled for any CPU time, unless it’s
interrupted. To make a thread of execution sleep, call <code>Thread.sleep()</code>
in that thread of execution with a number of milliseconds as a
parameter. For example, calling <code>Thread.sleep(2000)</code> will make the
calling thread sleep for two full seconds.</p>
</div>
<div class="paragraph">
<p>Another useful tool is the <code>Thread.yield()</code> method. It gives up use of
the CPU so that the next waiting thread can run. To use it, a thread
calls <code>Thread.yield()</code>. This method is useful in practice, but
according to official documentation, the JVM doesn’t <strong>have</strong> to do to
anything when a <code>Thread.yield()</code> call happens. The Java specification
doesn’t demand a particular implementation. A JVM could ignore a
<code>Thread.yield()</code> call completely, but most JVMs will move on to the next
thread in the schedule.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><a href="chap13.html#sleepAndYieldMethodsExercise">Exercício 13.3</a><br>
<a href="chap13.html#sleepTimerExercise">Exercício 13.13</a></p>
</div>
</div>
</div>
<div id="figure-thread_states" class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/thread-states.svg" alt="thread states" width="80%">
</div>
<div class="title">Figura 13.7 Thread states and transitions.</div>
</div>
<div class="paragraph">
<p><a href="chap13.html#figure-thread_states">Figura 13.7</a> shows the lifecycle of a thread. A
thread begins its life in the New Thread state, after the constructor is
called. When the <code>start()</code> method is called, the thread begins to run
and transitions to the Runnable state. Being Runnable doesn’t
necessarily mean that the thread is executing at any given moment but
that it’s ready to run at any time. When in the Runnable state, a
thread may call <code>Thread.yield()</code>, relinquishing use of the processor,
but it will still remain Runnable.</p>
</div>
<div class="paragraph">
<p>However, if a thread goes to sleep with a <code>Thread.sleep()</code> call, waits
for a condition to be true using a <code>wait()</code> call, or performs a blocking
I/O operation, the thread will transition to the Not Runnable state. Not
Runnable threads cannot be scheduled for processor time until they wake
up, finish waiting, or complete their I/O. The final state is
Terminated. A thread becomes Terminated when its <code>run()</code> method
finishes. A Terminated thread cannot become Runnable again and is no
longer a separate thread of execution.</p>
</div>
<div class="paragraph">
<p>Any object with a type that’s a subclass of <code>Thread</code> can tell you its
current state using the <code>getState()</code> method. This method returns an
<em>enum</em> type, whose value must come from a fixed list of constant
objects. These objects are <code>Thread.State.NEW</code>, <code>Thread.State.RUNNABLE</code>,
<code>Thread.State.BLOCKED</code>, <code>Thread.State.WAITING</code>,
<code>Thread.State.TIMED_WAITING</code>, and <code>Thread.State.TERMINATED</code>. Although
the others are self explanatory, we lump the <code>Thread.State.BLOCKED</code>,
<code>Thread.State.WAITING</code>, and <code>Thread.State.TIMED_WAITING</code> values into
the Not Runnable state, since the distinction between the three isn’t
important for us.</p>
</div>
<div class="paragraph">
<p>Threads also have priorities in Java. When an object that’s a subclass
of <code>Thread</code> is created in Java, its priority is initially the same as
the thread that creates it. Usually, this priority is
<code>Thread.NORM_PRIORITY</code>, but there are some special cases when it’s a
good idea to raise or lower this priority. Avoid changing thread
priorities because it increases platform dependence and because the
effects are not always predictable. Be aware that priorities exist, but
don’t use them unless and until you have a good reason.</p>
</div>
<div class="exampleblock">
<div class="title">Exemplo 13.12 Military marching</div>
<div class="content">
<div class="paragraph">
<p>Let’s apply the ideas discussed above to a lighthearted example. You
might be familiar with sound of soldiers marching: “Left, Left, Left,
Right, Left!” We can design a thread that prints <code>Left</code> and another
thread that prints <code>Right</code>. We can combine the two to print the correct
sequence for marching and loop the whole thing 10 times so that we can
see how accurately we can place the words. We want to use the scheduling tools
discussed above to get the timing right. Let’s try <code>Thread.sleep()</code>
first.</p>
</div>
<div id="LeftThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeftThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>  <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <span class="o">}</span>  <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Left"</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inside, the <code>for</code> loop, this thread prints out <code>Left</code> three times.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The, it waits for 10 milliseconds.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Finally, it prints out <code>Left</code> again and repeats the loop.</td>
</tr>
</tbody></table>
</div>
<div id="RightThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RightThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">try</span> <span class="o">{</span>
			<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Right "</span><span class="o">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
				<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
			<span class="o">}</span>
		<span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This thread waits for 5 milliseconds to get synchronized.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inside its <code>for</code> loop, it prints out <code>Right</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then, it waits for 10 milliseconds and repeats the loop.</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The driver program below creates a thread for each of these
classes and then starts them. If you run this program, you should see 10
lines of <code>Left Left Left Right Left</code>, but there are a few problems.</p>
</div>
<div id="MilitaryMarchingProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MilitaryMarching</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">LeftThread</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LeftThread</span><span class="o">();</span>
        <span class="nc">RightThread</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RightThread</span><span class="o">();</span>
        <span class="n">left</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">right</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">left</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">right</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>       
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first problem is that we have to wait some amount of time between
calls. We could shorten the <code>Thread.sleep()</code> calls, but there are limits
on the resolution of the timer. The bigger problem is that the two
threads can sometimes get out of sync. If you run the program many
times, you might see a <code>Right</code> out of place once in a while. If you
increase the repetitions of the <code>for</code> loops to a larger number, the
errors will become more likely. Whether or not you see errors is somewhat system
dependent. We can try <code>Thread.yield()</code> instead of <code>Thread.sleep()</code>.</p>
</div>
<div id="LeftYieldThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeftYieldThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>              
            <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>         
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Left"</span><span class="o">);</span>                 
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div id="RightYieldThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RightYieldThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>         
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Right "</span><span class="o">);</span>         
            <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These new versions of the two classes have essentially replaced calls to
<code>Thread.sleep()</code> with calls to <code>Thread.yield()</code>. Without the need for
exception handling, the code is simpler, but we’ve traded one set of
problems for another. If there are other threads operating in the same
application, they’ll be scheduled in ways that will interfere with the
pattern of yielding. If you’re running this code on a machine
with a single processor and a single core, you have a good chance of
seeing something which matches the expected output. However, if you’re running
it on multiple cores, everything will be jumbled. It’s likely that
the <code>LeftYieldThread</code> will be running on one processor with the
<code>RightYieldThread</code> on another. In that case, neither has any competition
to yield to.</p>
</div>
<div class="paragraph">
<p>Finally, let’s look at a polling solution which still falls short of
the mark. To do this, we need state variables inside of each class to
keep track of whether or not it’s done. Each thread needs a reference
to the other thread to make queries, and the driver program must be
updated to add these in before starting the threads.</p>
</div>
<div id="LeftPollingThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeftPollingThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">RightPollingThread</span> <span class="n">right</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRight</span><span class="o">(</span><span class="nc">RightPollingThread</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Left "</span><span class="o">);</span>          
            <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>            
            <span class="k">while</span><span class="o">(!</span><span class="n">right</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>           
            <span class="n">right</span><span class="o">.</span><span class="na">setDone</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>                     
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Left"</span><span class="o">);</span>                 
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDone</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">done</span><span class="o">;</span> <span class="o">}</span>    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDone</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">done</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div id="RightPollingThreadProgram" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RightPollingThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">LeftPollingThread</span> <span class="n">left</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">done</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>   
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLeft</span><span class="o">(</span><span class="nc">LeftPollingThread</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>             
            <span class="k">while</span><span class="o">(!</span><span class="n">left</span><span class="o">.</span><span class="na">isDone</span><span class="o">());</span>            
            <span class="n">left</span><span class="o">.</span><span class="na">setDone</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>            
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Right "</span><span class="o">);</span>         
            <span class="n">done</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDone</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">done</span><span class="o">;</span> <span class="o">}</span>    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDone</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">done</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Whether single core or multicore, this solution will always give the
right output. Or it should. Java experts will point out that we are
violating a technicality of the Java Memory Model. Because we’re not
using synchronization tools, we have no guarantee that the change of the
<code>done</code> variable will even be <strong>visible</strong> from one thread to another. In
practice, this problem should affect you rarely, but to be safe, both of
the <code>done</code> variables should be declared with the keyword <code>volatile</code>.
This keyword makes Java aware that the value may be accessed at any time
from arbitrary threads.</p>
</div>
<div class="paragraph">
<p>Another issue is that there’s <strong>no</strong> parallel execution. Each thread must wait
for the other to complete. Of course, this problem does not benefit from
a parallelism, but applying this solution to problems which can
benefit from parallelism might cause performance problems. Each thread
wastes time busy waiting in a <code>while</code> loop for the other to be done,
consuming CPU cycles while it does so. You’ll notice that the code
must still be carefully written. Each thread must set the other thread’s
<code>done</code> value to <code>false</code>. If threads were responsible for setting their
own <code>done</code> values to <code>false</code>, one thread might print its information and
go back to the top of the <code>for</code> loop before the other thread had reset
its own <code>done</code> to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>In short, coordinating two or more threads together is a difficult
problem. None of the solutions we give here are fully acceptable. We
introduce better tools for coordination and synchronization in
<a href="chap14.html">Chapter 14</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_solution_deadly_virus">13.8. Solution: Deadly virus</h3>
<div class="paragraph">
<p>Finally, we give the solution to the deadly virus problem. By this
point, the threaded part of this problem should not seem very difficult.
It’s simpler than some of the examples, such as matrix multiplication.
We begin with the worker class <code>FactorThread</code> that can be spawned as a
thread.</p>
</div>
<div id="FactorThreadProgram" class="listingblock">
<div class="title">Programa 13.1 Thread class used to find the sum of the two factors of a large odd composite.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactorThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>  
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lower</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">upper</span><span class="o">;</span> 
    
    <span class="kd">public</span> <span class="nf">FactorThread</span><span class="o">(</span><span class="kt">long</span> <span class="n">lower</span><span class="o">,</span> <span class="kt">long</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>     
        <span class="k">this</span><span class="o">.</span><span class="na">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>     
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">if</span><span class="o">(</span><span class="n">lower</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// Only check odd numbers</span>
            <span class="n">lower</span><span class="o">++;</span>        
        <span class="k">while</span><span class="o">(</span><span class="n">lower</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Factor</span><span class="o">.</span><span class="na">NUMBER</span> <span class="o">%</span> <span class="n">lower</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Security code: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">lower</span> <span class="o">+</span> <span class="nc">Factor</span><span class="o">.</span><span class="na">NUMBER</span> <span class="o">/</span> <span class="n">lower</span><span class="o">));</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">lower</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>           
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor for <code>FactorThread</code> takes an upper and lower bound,
similar to <code>MatrixThread</code>. Once a <code>FactorThread</code> object has those
bounds, it can search between them. The number to factor is stored in
the <code>Factor</code> class. If any value divides that number evenly, it must be
one of the factors, making the other factor easy to find, sum, and print
out. We have to add a couple of extra lines of code to make sure that we
only search the odd numbers in the range. This solution is tuned for
efficiency for this specific security problem. A program to find general
prime factors would have to be more flexible. Next, let’s examine the
driver program <code>Factor</code>.</p>
</div>
<div id="FactorProgram" class="listingblock">
<div class="title">Programa 13.2 Driver class which creates threads to lower the average search time for the factors of a large odd composite.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THREADS</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">NUMBER</span> <span class="o">=</span> <span class="mi">59984005171248659L</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FactorThread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FactorThread</span><span class="o">[</span><span class="no">THREADS</span><span class="o">];</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="kt">long</span> <span class="n">root</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="no">NUMBER</span><span class="o">);</span> <span class="c1">// Go to square root</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>  <span class="c1">// No need to test 2       </span>
        <span class="kt">long</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">root</span> <span class="o">/</span> <span class="no">THREADS</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">root</span> <span class="o">%</span> <span class="no">THREADS</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">work</span> <span class="o">=</span> <span class="n">quotient</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="o">)</span>
                <span class="n">work</span><span class="o">++;</span>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FactorThread</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">work</span><span class="o">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">work</span><span class="o">;</span>
        <span class="o">}</span>   
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">THREADS</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Static constants hold both the number to be factored and the number of
threads.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In the <code>main()</code> method, we create an array of threads for
storage.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then, we create and start each <code>FactorThread</code> object, assigning upper and
lower bounds at the same time, using the standard technique from
<a href="chap6.html#_concurrency_arrays">Section 6.11</a> to divide the work fairly. Because we
know the number we’re dividing isn’t even, we start with 3. By only
going up to the square root of the number, we know that we will only
find the smaller of the two factors. In that way we can avoid having one
thread find the smaller while another is finds the larger.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Afterward, we have the usual <code>join()</code> calls to make sure that all the
threads are done. In this problem, these calls are unnecessary. One
thread will print out the correct security code, and the others will
search fruitlessly. If the program went on to do other work, we might
need to let the other threads finish or even interrupt them. Don’t
forget <code>join()</code> calls since they’re usually very important.</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_summary_5">13.9. Summary</h3>
<div class="paragraph">
<p>In this chapter we’ve explored
two strategies to obtain a concurrent solution to programming problems.
One strategy, task decomposition, splits a task into two or more
subtasks. These subtasks can then be packaged as Java threads and
executed on different cores of a multicore processor. Another strategy,
domain decomposition, partitions input data into smaller chunks and
allows different threads to work concurrently on each chunk of data.</p>
</div>
<div class="paragraph">
<p>A concurrent solution to a programming problem can sometimes execute more quickly
than a sequential solution. Speedup measure how effective a concurrent
solution is at exploiting the architecture of a multicore processor.
Note that not all concurrent programs lead to speedup as some run slower
than their sequential counterparts. Writing a concurrent program is a
challenge that forces us to divide up work and data in a
way that best exploits the available processors and OS.</p>
</div>
<div class="paragraph">
<p>Java provides a rich set of primitives and syntactic elements to write
concurrent programs, but only a few of these were introduced in this
chapter. Subsequent chapters give additional tools to code more complex
concurrent programs.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exercises_13">13.10. Exercises</h3>
<div class="paragraph">
<p><strong>Conceptual Problems</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a id="threadMethodsExercise"></a> The <code>start()</code>, <code>run()</code>, and <code>join()</code>
methods are essential parts of the process of using threads in Java.
Explain the purpose of each method.</p>
</li>
<li>
<p><a id="extendingThreadExercise"></a> What’s the difference between
extending the <code>Thread</code> class and implementing the <code>Runnable</code> interface?
When should you use one over the other?</p>
</li>
<li>
<p><a id="sleepAndYieldMethodsExercise"></a> How do the <code>Thread.sleep()</code> method and
the <code>Thread.yield()</code> method each affect thread scheduling?</p>
</li>
<li>
<p><a id="mathExpressionTimingExercise"></a> Consider the expression in
<a href="chap13.html#mathExpressionTasksExample">Exemplo 13.2</a>. Suppose that the multiply and
exponentiation operations require 1 and 10 time units, respectively.
Compute the number of time units required to evaluate the expression as
in <a href="chap13.html#figure-math_evaluation">Figura 13.2</a>(a) and (b).</p>
</li>
<li>
<p><a id="quad-coreExercise"></a> Suppose that a computer has one
quad-core processor. Can the tasks in <a href="chap13.html#videoGameTasksExample">Exemplo 13.1</a> and <a href="chap13.html#mathExpressionTasksExample">Exemplo 13.2</a> be further subdivided to
improve performance on four cores? Why or why not?</p>
</li>
<li>
<p><a id="speedupExercise"></a> Consider the definition of speedup from
<a href="#Examples: Concurrency and speedup" class="target-missing">[Examples: Concurrency and speedup]</a>. Let’s assume you have a
job 1,000,000 units in size. A thread can process 10,000 units of work
every second. It takes an additional 100 units of work to create a new
thread. What’s the speedup if you have a dual-core processor and create
2 threads? What if you have a quad-core processor and create 4 threads?
Or an 8-core processor and create 8 threads? You may assume that a
thread does not need to communicate after it’s been created.</p>
</li>
<li>
<p><a id="speedupLimitationsExercise"></a> In which situations can speedup be
smaller than the number of processors? Is it ever possible for speedup
to be greater than the number of processors?</p>
</li>
<li>
<p><a id="AmdahlLawExercise"></a> Amdahl’s Law is a mathematical description of
the maximum amount you can improve a system by only improving a part of
it. One form of it states that the maximum speedup attainable in a
parallel program is 1/(1 - <em>P</em>) where <em>P</em>
is the fraction of the program which can be parallelized to an arbitrary
degree. If 30% of the work in a program can be fully parallelized but
the rest is completely serial, what’s the speedup with two processors? Four?
Eight? What implications does Amdahl’s Law have?</p>
</li>
<li>
<p><a id="minimumTimeForTasksExercise"></a> Consider the following table of
tasks:</p>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle">Task</th>
<th class="tableblock halign-center valign-middle">Time</th>
<th class="tableblock halign-center valign-middle">Concurrency</th>
<th class="tableblock halign-left valign-middle">Dependency</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Washing Dishes</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Cooking Dinner</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">45</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Washing Dishes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Cleaning Bedroom</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Cleaning Bathroom</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Doing Homework</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">30</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Cleaning Bedroom</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In this table, the <strong>Time</strong> column gives the number of minutes a task
takes to perform with a single person, the <strong>Concurrency</strong> column gives
the maximum number of people who can be assigned to a task, and the
<strong>Dependency</strong> column shows which tasks can’t start until other tasks
have been finished. Assume that people assigned to a given task can
perfectly divide the work. In other words, the time a task takes is the
single person time divided by the number of people assigned. What’s the
minimum amount of time needed to perform all tasks with only a single
person? What is the minimum amount of time needed to perform all tasks
with an unlimited number of people? What’s the smallest number of
people needed to achieve this minimum time?</p>
</div>
</li>
<li>
<p><a id="sharedThreadVariableExercise"></a> Consider the following code snippet.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">x</span> <span class="o">=</span> <span class="mi">13</span><span class="o">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider this snippet as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we assume that these two snippets of code are running on separate
threads but that <code>x</code> is a shared variable, what are the possible values
<code>x</code> could have after both snippets have run? Remember that the execution
of these snippets can be interleaved in <strong>any</strong> way.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Programming Practice</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic" start="11">
<li>
<p><a id="pollingArraySumExercise"></a> Re-implement the array summing problem from
<a href="chap13.html#arraySummationExample">Exemplo 13.10</a> using polling instead of <code>join()</code>
calls. Your program should not use a single call to <code>join()</code>. Polling is
not an ideal way to solve this problem, but it’s worth thinking about the technique.</p>
</li>
<li>
<p><a id="parallelAudioProcessingExercise"></a> Composers often work with multiple tracks
of music. One track might contain solo vocals, another drums, a third
one violins, and so on. After recording the entire take, a mix engineer
might want to apply special effects such as an echo to one or more
tracks.</p>
<div class="paragraph">
<p>To understand how to add echo to a track, suppose that the track
consists of a list of audio samples. Each sample in a mono (not stereo)
track can be stored as a <code>double</code> in an array. To create an echo effect,
we combine the current value of an audio sample with a sample from a
fixed time earlier. This time is called the <em>delay</em> parameter. Varying
the delay can produce long and short echoes.</p>
</div>
<div class="paragraph">
<p>If the samples are stored in array <code>in</code> and the delay parameter is
stored in variable <code>delay</code> (measured in number of samples), the following code snippet can be used to
create array <code>out</code> which contains the sound with an echo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">double</span><span class="o">[]</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">in</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">delay</span><span class="o">];</span>
<span class="c1">// Sound before echo starts</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">delay</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">out</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">in</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="c1">// Sound with echo</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">delay</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">out</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">in</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">in</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delay</span><span class="o">];</span>
<span class="c1">// Echo after sound is over</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">out</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">out</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">in</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delay</span><span class="o">];</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Parameters <code>a</code> and <code>b</code> are used to control the nature of the echo. When
<code>a</code> is <code>1</code> and <code>b</code> is <code>0</code>, there is no echo. When <code>a</code> is <code>0</code> and <code>b</code> is
<code>1</code>, there is no mixing. Audio engineers will control the values of <code>a</code>
and <code>b</code> to create the desired echo effect.</p>
</div>
<div class="paragraph">
<p>Write a threaded program that computes the values in <code>out</code> in parallel
for an arbitrary number of threads.</p>
</div>
</li>
<li>
<p><a id="sleepTimerExercise"></a> Write a program which takes a number of
minutes and seconds as input. In this program, implement a timer using
<code>Thread.sleep()</code> calls. Each second, print the remaining time to the
screen. How accurate is your timer?</p>
</li>
<li>
<p><a id="parallelPiApproximationExercise"></a> As you know,
<em>π</em> ≈ 3.1416. A more precise value can be found by writing a program which
approximates the area of a circle. The area of a circle can be
approximated by summing up the area of rectangles filling curve of the
arc of the circle. As the width of the rectangle goes to zero, the
approximation becomes closer and closer to the true area. If a circle with radius
<em>r</em> is centered at the origin, its height <em>y</em> at a particular
distance <em>x</em> is given by the following formula.</p>
<div class="imageblock text-center">
<div class="content">
<img src="chapters/13-concurrency/images/circleHeight.svg" alt="circleHeight" width="15%">
</div>
</div>
<div class="paragraph">
<p>Write a parallel implementation of this problem which divides up
portions of the arc of the circle among several threads and then sums
the results after they all finish. By setting <em>r</em> = 2, you
need only sum one quadrant of a circle to get <em>π</em>. You’ll need to
use a very small rectangle width to get an accurate answer.
When your program finishes running, you can compare your value against
<code>Math.PI</code> for accuracy.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Experiments</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic" start="15">
<li>
<p><a id="executionVariationExercise"></a> Use the <code>currentTimeMillis()</code> method
to measure the time taken to execute a relatively long-running piece of
Java code you’ve written. Execute your program several times and
compare the execution time you obtain during different executions. Why
do you think the execution times are different?</p>
</li>
<li>
<p><a id="threadOverheadExercise"></a> Thread creation overhead is an
important consideration in writing efficient parallel programs. Write a
program which creates a large number of threads which do nothing. Test
how long it takes to create and join various numbers of threads. See if
you can determine how long a single thread creation operation takes on
your system, on average.</p>
</li>
<li>
<p><a id="matrixSpeedupExercise"></a> Create serial and concurrent
implementations of matrix multiplication like those described in
<a href="chap13.html#matrixMultiplicationExample">Exemplo 13.11</a>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Experiment with different matrix sizes and thread counts to see how
the speedup performance changes. If possible, run your tests on machines
with different numbers of cores or processors.</p>
</li>
<li>
<p>Given a machine with <em>k</em> &gt; 1 cores, what is the maximum
speedup you can expect to obtain?</p>
</li>
</ol>
</div>
</li>
<li>
<p><a id="executionOrderExercise"></a> Repeatedly run the code in
<a href="chap13.html#arrayOfThreadsExample">Exemplo 13.7</a> which creates several
<code>NumberedThread</code> objects. Can you discover any patterns in the order
that the threads print? Add a loop and some additional instrumentation
to the <code>NumberedThread</code> class which will allow you to measure how long
each thread runs before the next thread has a turn.</p>
</li>
<li>
<p><a id="arraySummingSpeedupExercise"></a> Create serial and parallel implementations of
the array summing problem solved in <a href="chap13.html#arraySummationExample">Exemplo 13.10</a>.
Experiment with different array sizes and thread counts to see how
performance changes. How does the speedup differ from matrix multiply?
What happens if you simply sum the numbers instead of taking the sine
first?</p>
</li>
<li>
<p><a id="treeSummationExercise"></a> The solution to the array summing problem in
<a href="chap13.html#arraySummationExample">Exemplo 13.10</a> seems to use concurrency
half-heartedly. After all the threads have computed their sums, the main
thread sums up the partial sums sequentially.</p>
<div class="paragraph">
<p>An alternative approach is to sum up the partial sums concurrently. Once
a thread has computed the sum of the sines of each partition, the sums
of each pair of neighboring partitions should be merged into a single
sum. The process can be repeated until the final sum has been computed.
At each step, half of the remaining threads will have nothing left to do
and will stop. The pattern of summing is like a tree which starts with
<em>k</em> threads working at the first stage,
<em>k</em>/2 working at the second stage,
<em>k</em>/4 working at the third, and so on, until a
single thread completes the summing process.</p>
</div>
<div id="figure-tree_summation" class="imageblock">
<div class="content">
<img src="chapters/13-concurrency/images/treesummation.svg" alt="treesummation" width="100%">
</div>
<div class="title">Figura 13.8 Example of concurrent tree-style summation with 8 threads.</div>
</div>
<div class="paragraph">
<p>Update the <code>run()</code> method in the <code>SumThread</code> class so that it adds its
assigned elements as before and then adds its neighbor’s sum to its own.
To do so, it must use the <code>join()</code> method to wait for the neighboring
thread. It should perform this process repeatedly. After summing their
own values, each even numbered thread should add in the partial sum from
its neighbor. At the next step, each thread with a number divisible by 4
should add the partial sum from its neighbor. At the next step, each
thread with a number divisible by 8 should add the partial sum from its
neighbor, and so on. Thread 0 will perform the final summation.
Consequently, the main thread only needs to wait for thread 0. So that
each thread can wait for other threads, the <code>threads</code> array will need to
be a static field. <a href="chap13.html#figure-tree_summation">Figura 13.8</a> illustrates this
process.</p>
</div>
<div class="paragraph">
<p>Once you’ve implemented this design, test it against the original
<code>SumThread</code> class to see how it performs. Restrict the number of threads
you create to a power of 2 to make it easier to determine which threads
wait and which threads terminate.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div></div>

<nav>
  <a rel="prev" href="chap12.html" class="nav nav-prev" title="Previous page" aria-label="Previous page" aria-keyshortcuts="Left">
        <i class="fa fa-angle-left"></i>
     </a>
  <a rel="next" href="chap14.html" class="nav nav-next" title="Next page" aria-label="Next page" aria-keyshortcuts="Right">
        <i class="fa fa-angle-right"></i>
     </a>
  <div style="clear: both"></div>
</nav>
<div id="footer">
<div id="footer-text">
Last updated 2024-05-20 18:00:47 -0300
</div>
</div>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VEDGKRPMMK"></script>
          <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-VEDGKRPMMK');
          </script>

</body>
  <script>
  function isInViewport(ele) {
    const rect = ele.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
    );
  }
  function yPosition (ele) {
    const rect = ele.getBoundingClientRect();
    return (rect.top - 20); // 20px above
  }
  let curr = document.getElementsByClassName('current');
  if (!isInViewport(curr[curr.length - 1])) {
    document.getElementById('toc').scrollTo({
      top: yPosition(curr[0]),
      left: 0,
      behavior: 'smooth'
    });
  }

  /* For page navigation */
  function gotoPage(selector) {
    const button = document.querySelector(selector);
    if (button)
      window.location.href = button.href;
  }
  document.addEventListener('keydown', e => {
    if (e.shiftKey)
      return;
    switch (e.key) {
      case 'ArrowRight':
        e.preventDefault();
        gotoPage('.nav-next');
        break;
      case 'ArrowLeft':
        e.preventDefault();
        gotoPage('.nav-prev');
        break;
    }
  });
  </script>
  </html>